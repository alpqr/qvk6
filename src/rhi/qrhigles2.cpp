/****************************************************************************
**
** Copyright (C) 2018 The Qt Company Ltd.
** Contact: http://www.qt.io/licensing/
**
** This file is part of the Qt RHI module
**
** $QT_BEGIN_LICENSE:LGPL3$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see http://www.qt.io/terms-conditions. For further
** information use the contact form at http://www.qt.io/contact-us.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 3 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPLv3 included in the
** packaging of this file. Please review the following information to
** ensure the GNU Lesser General Public License version 3 requirements
** will be met: https://www.gnu.org/licenses/lgpl.html.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 2.0 or later as published by the Free
** Software Foundation and appearing in the file LICENSE.GPL included in
** the packaging of this file. Please review the following information to
** ensure the GNU General Public License version 2.0 requirements will be
** met: http://www.gnu.org/licenses/gpl-2.0.html.
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include "qrhigles2_p.h"
#include <QWindow>

QT_BEGIN_NAMESPACE

/*
  This is a OpenGL ES 2.0 + GLSL (ES) 100 level backend. Uniform buffers, MSAA,
  depth textures, etc. are not supported. Binding vertex attribute locations
  and, most importantly, decomposing uniform buffers into uniforms (as expected
  by the GLSL 100 shader generated by SPIRV-Cross) are handled transparently to
  the application via the reflection data (QShaderDescription).
*/

QRhiGles2::QRhiGles2(QRhiInitParams *params)
{
    QRhiGles2InitParams *glparams = static_cast<QRhiGles2InitParams *>(params);
    ctx = glparams->context;
    fallbackSurface = glparams->nonVisualSurface;

    create();
}

QRhiGles2::~QRhiGles2()
{
    destroy();
}

// Initialization, teardown, beginFrame(), and every build() take care of
// making the context and the (window or fallback) surface current, if needed.
// Others do not - if the applications mess with the GL context on the thread
// within a begin-endFrame, it is up to them to restore before entering the
// next rhi function that may issue GL calls.

void QRhiGles2::ensureContext(QSurface *surface)
{
    bool nativeWindowGone = false;
    if (surface && surface->surfaceClass() == QSurface::Window && !surface->surfaceHandle()) {
        surface = fallbackSurface;
        nativeWindowGone = true;
    }

    // When surface is null, we do not know what surface to use (since only
    // begin-endFrame is tied to a swapchain; the concept maps badly to GL
    // where any build() needs a current context as well). Use the
    // QOffscreenSurface in this case - but note the early out below which
    // minimizes changes since a window surface (from the swapchain) is good
    // enough as well when it's still current.
    if (!surface)
        surface = fallbackSurface;

    // Minimize makeCurrent calls since it is not guaranteed to have any
    // return-if-same checks internally. Make sure the makeCurrent is never
    // omitted after a swapBuffers, and when surface was specified explicitly.
    if (buffersSwapped)
        buffersSwapped = false;
    else if (!nativeWindowGone && QOpenGLContext::currentContext() == ctx && (surface == fallbackSurface || ctx->surface() == surface))
        return;

    if (!ctx->makeCurrent(surface))
        qWarning("QRhiGles2: Failed to make context current. Expect bad things to happen.");
}

void QRhiGles2::create()
{
    Q_ASSERT(ctx);
    Q_ASSERT(fallbackSurface);

    ensureContext();

    f = ctx->functions();

    const char *vendor = reinterpret_cast<const char *>(f->glGetString(GL_VENDOR));
    const char *renderer = reinterpret_cast<const char *>(f->glGetString(GL_RENDERER));
    const char *version = reinterpret_cast<const char *>(f->glGetString(GL_VERSION));
    if (vendor && renderer && version)
        qDebug("OpenGL VENDOR: %s RENDERER: %s VERSION: %s", vendor, renderer, version);
}

void QRhiGles2::destroy()
{
    if (!f)
        return;

    ensureContext();
    executeDeferredReleases();

    f = nullptr;
}

void QRhiGles2::executeDeferredReleases()
{
    for (int i = releaseQueue.count() - 1; i >= 0; --i) {
        const QRhiGles2::DeferredReleaseEntry &e(releaseQueue[i]);
        switch (e.type) {
        case QRhiGles2::DeferredReleaseEntry::Buffer:
            f->glDeleteBuffers(1, &e.buffer.buffer);
            break;
        case QRhiGles2::DeferredReleaseEntry::Pipeline:
            f->glDeleteProgram(e.pipeline.program);
            break;
        case QRhiGles2::DeferredReleaseEntry::Texture:
            f->glDeleteTextures(1, &e.texture.texture);
            break;
        default:
            break;
        }
        releaseQueue.removeAt(i);
    }
}

QVector<int> QRhiGles2::supportedSampleCounts() const
{
    return { 1 };
}

QRhiSwapChain *QRhiGles2::createSwapChain()
{
    return new QGles2SwapChain(this);
}

QRhiBuffer *QRhiGles2::createBuffer(QRhiBuffer::Type type, QRhiBuffer::UsageFlags usage, int size)
{
    return new QGles2Buffer(this, type, usage, size);
}

int QRhiGles2::ubufAlignment() const
{
    return 256;
}

QMatrix4x4 QRhiGles2::openGLCorrectionMatrix() const
{
    return QMatrix4x4(); // identity
}

QRhiRenderBuffer *QRhiGles2::createRenderBuffer(QRhiRenderBuffer::Type type, const QSize &pixelSize, int sampleCount)
{
    return new QGles2RenderBuffer(this, type, pixelSize, sampleCount);
}

QRhiTexture *QRhiGles2::createTexture(QRhiTexture::Format format, const QSize &pixelSize, QRhiTexture::Flags flags)
{
    return new QGles2Texture(this, format, pixelSize, flags);
}

QRhiSampler *QRhiGles2::createSampler(QRhiSampler::Filter magFilter, QRhiSampler::Filter minFilter,
                                      QRhiSampler::Filter mipmapMode,
                                      QRhiSampler::AddressMode u, QRhiSampler::AddressMode v)
{
    return new QGles2Sampler(this, magFilter, minFilter, mipmapMode, u, v);
}

QRhiTextureRenderTarget *QRhiGles2::createTextureRenderTarget(QRhiTexture *texture,
                                                              QRhiTextureRenderTarget::Flags flags)
{
    return new QGles2TextureRenderTarget(this, texture, flags);
}

QRhiTextureRenderTarget *QRhiGles2::createTextureRenderTarget(QRhiTexture *texture,
                                                              QRhiRenderBuffer *depthStencilBuffer,
                                                              QRhiTextureRenderTarget::Flags flags)
{
    return new QGles2TextureRenderTarget(this, texture, depthStencilBuffer, flags);
}

QRhiTextureRenderTarget *QRhiGles2::createTextureRenderTarget(QRhiTexture *texture,
                                                              QRhiTexture *depthTexture,
                                                              QRhiTextureRenderTarget::Flags flags)
{
    return new QGles2TextureRenderTarget(this, texture, depthTexture, flags);
}

QRhiGraphicsPipeline *QRhiGles2::createGraphicsPipeline()
{
    return new QGles2GraphicsPipeline(this);
}

QRhiShaderResourceBindings *QRhiGles2::createShaderResourceBindings()
{
    return new QGles2ShaderResourceBindings(this);
}

void QRhiGles2::setGraphicsPipeline(QRhiCommandBuffer *cb, QRhiGraphicsPipeline *ps, QRhiShaderResourceBindings *srb)
{
    Q_ASSERT(inPass);

    if (!srb)
        srb = ps->shaderResourceBindings;

    QGles2GraphicsPipeline *psD = QRHI_RES(QGles2GraphicsPipeline, ps);
    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);

    if (cbD->currentPipeline != ps || cbD->currentPipelineGeneration != psD->generation) {
        cbD->currentPipeline = ps;
        cbD->currentPipelineGeneration = psD->generation;

        QGles2CommandBuffer::Command cmd;
        cmd.cmd = QGles2CommandBuffer::Command::BindGraphicsPipeline;
        cmd.args.bindGraphicsPipeline.ps = ps;
        cmd.args.bindGraphicsPipeline.srb = srb;
        cbD->commands.append(cmd);
    }
}

void QRhiGles2::setVertexInput(QRhiCommandBuffer *cb, int startBinding, const QVector<QRhi::VertexInput> &bindings,
                               QRhiBuffer *indexBuf, quint32 indexOffset, QRhi::IndexFormat indexFormat)
{
    Q_ASSERT(inPass);
    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);

    for (int i = 0, ie = bindings.count(); i != ie; ++i) {
        QRhiBuffer *buf = bindings[i].first;
        // ignore offset, no glBindBufferRange
        QGles2Buffer *bufD = QRHI_RES(QGles2Buffer, buf);
        Q_ASSERT(buf->usage.testFlag(QRhiBuffer::VertexBuffer));
        QGles2CommandBuffer::Command cmd;
        cmd.cmd = QGles2CommandBuffer::Command::BindVertexBuffer;
        cmd.args.bindVertexBuffer.ps = cbD->currentPipeline;
        cmd.args.bindVertexBuffer.buffer = bufD->buffer;
        cmd.args.bindVertexBuffer.binding = startBinding + i;
        cbD->commands.append(cmd);
    }

    if (indexBuf) {
        QGles2Buffer *ibufD = QRHI_RES(QGles2Buffer, indexBuf);
        Q_ASSERT(indexBuf->usage.testFlag(QRhiBuffer::IndexBuffer));
        Q_UNUSED(indexOffset); // no glBindBufferRange
        QGles2CommandBuffer::Command cmd;
        cmd.cmd = QGles2CommandBuffer::Command::BindIndexBuffer;
        cmd.args.bindIndexBuffer.buffer = ibufD->buffer;
        cmd.args.bindIndexBuffer.type = indexFormat == QRhi::IndexUInt16 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT;
        cbD->commands.append(cmd);
    }
}

void QRhiGles2::setViewport(QRhiCommandBuffer *cb, const QRhiViewport &viewport)
{
    Q_ASSERT(inPass);
    QGles2CommandBuffer::Command cmd;
    cmd.cmd = QGles2CommandBuffer::Command::Viewport;
    cmd.args.viewport.x = viewport.r.x();
    cmd.args.viewport.y = viewport.r.y();
    cmd.args.viewport.w = viewport.r.width();
    cmd.args.viewport.h = viewport.r.height();
    cmd.args.viewport.d0 = viewport.minDepth;
    cmd.args.viewport.d1 = viewport.maxDepth;
    QRHI_RES(QGles2CommandBuffer, cb)->commands.append(cmd);
}

void QRhiGles2::setScissor(QRhiCommandBuffer *cb, const QRhiScissor &scissor)
{
    Q_ASSERT(inPass);
    QGles2CommandBuffer::Command cmd;
    cmd.cmd = QGles2CommandBuffer::Command::Scissor;
    cmd.args.scissor.x = scissor.r.x();
    cmd.args.scissor.y = scissor.r.y();
    cmd.args.scissor.w = scissor.r.width();
    cmd.args.scissor.h = scissor.r.height();
    QRHI_RES(QGles2CommandBuffer, cb)->commands.append(cmd);
}

void QRhiGles2::setBlendConstants(QRhiCommandBuffer *cb, const QVector4D &c)
{
    Q_ASSERT(inPass);
    QGles2CommandBuffer::Command cmd;
    cmd.cmd = QGles2CommandBuffer::Command::BlendConstants;
    cmd.args.blendConstants.r = c.x();
    cmd.args.blendConstants.g = c.y();
    cmd.args.blendConstants.b = c.z();
    cmd.args.blendConstants.a = c.w();
    QRHI_RES(QGles2CommandBuffer, cb)->commands.append(cmd);
}

void QRhiGles2::setStencilRef(QRhiCommandBuffer *cb, quint32 refValue)
{
    Q_ASSERT(inPass);
    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);

    QGles2CommandBuffer::Command cmd;
    cmd.cmd = QGles2CommandBuffer::Command::StencilRef;
    cmd.args.stencilRef.ref = refValue;
    cmd.args.stencilRef.ps = cbD->currentPipeline;
    cbD->commands.append(cmd);
}

void QRhiGles2::draw(QRhiCommandBuffer *cb, quint32 vertexCount,
                     quint32 instanceCount, quint32 firstVertex, quint32 firstInstance)
{
    Q_ASSERT(inPass);
    Q_UNUSED(instanceCount); // no instancing
    Q_UNUSED(firstInstance);
    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);

    QGles2CommandBuffer::Command cmd;
    cmd.cmd = QGles2CommandBuffer::Command::Draw;
    cmd.args.draw.ps = cbD->currentPipeline;
    cmd.args.draw.vertexCount = vertexCount;
    cmd.args.draw.firstVertex = firstVertex;
    cbD->commands.append(cmd);
}

void QRhiGles2::drawIndexed(QRhiCommandBuffer *cb, quint32 indexCount,
                            quint32 instanceCount, quint32 firstIndex, qint32 vertexOffset, quint32 firstInstance)
{
    Q_ASSERT(inPass);
    Q_UNUSED(instanceCount); // no instancing
    Q_UNUSED(firstInstance);
    Q_UNUSED(vertexOffset); // no glDrawElementsBaseVertex
    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);

    QGles2CommandBuffer::Command cmd;
    cmd.cmd = QGles2CommandBuffer::Command::DrawIndexed;
    cmd.args.drawIndexed.ps = cbD->currentPipeline;
    cmd.args.drawIndexed.indexCount = indexCount;
    cmd.args.drawIndexed.firstIndex = firstIndex;
    cbD->commands.append(cmd);
}

QRhi::FrameOpResult QRhiGles2::beginFrame(QRhiSwapChain *swapChain)
{
    Q_ASSERT(!inFrame);

    QGles2SwapChain *swapChainD = QRHI_RES(QGles2SwapChain, swapChain);
    ensureContext(swapChainD->surface);
    inFrame = true;

    executeDeferredReleases();
    QRHI_RES(QGles2CommandBuffer, &swapChainD->cb)->resetState();

    return QRhi::FrameOpSuccess;
}

QRhi::FrameOpResult QRhiGles2::endFrame(QRhiSwapChain *swapChain)
{
    Q_ASSERT(inFrame);

    QGles2SwapChain *swapChainD = QRHI_RES(QGles2SwapChain, swapChain);
    executeCommandBuffer(&swapChainD->cb);

    inFrame = false;
    ++finishedFrameCount;

    if (swapChainD->surface) {
        ctx->swapBuffers(swapChainD->surface);
        buffersSwapped = true;
    }

    return QRhi::FrameOpSuccess;
}

void QRhiGles2::applyPassUpdates(QRhiCommandBuffer *cb, const QRhi::PassUpdates &updates)
{
    Q_UNUSED(cb);

    for (const QRhi::DynamicBufferUpdate &u : updates.dynamicBufferUpdates) {
        Q_ASSERT(!u.buf->isStatic());
        QGles2Buffer *bufD = QRHI_RES(QGles2Buffer, u.buf);
        if (u.buf->usage.testFlag(QRhiBuffer::UniformBuffer)) {
            memcpy(bufD->ubuf.data() + u.offset, u.data.constData(), u.data.size());
            QGles2Buffer::ChangeRange &r(bufD->ubufChangeRange);
            if (r.changeBegin == -1 || u.offset < r.changeBegin)
                r.changeBegin = u.offset;
            if (r.changeEnd == -1 || u.offset + u.data.size() > r.changeEnd)
                r.changeEnd = u.offset + u.data.size();
        } else {
            f->glBindBuffer(bufD->target, bufD->buffer);
            f->glBufferSubData(bufD->target, u.offset, u.data.size(), u.data.constData());
        }
    }

    for (const QRhi::StaticBufferUpload &u : updates.staticBufferUploads) {
        Q_ASSERT(u.buf->isStatic());
        QGles2Buffer *bufD = QRHI_RES(QGles2Buffer, u.buf);
        Q_ASSERT(u.data.size() == u.buf->size);
        if (u.buf->usage.testFlag(QRhiBuffer::UniformBuffer)) {
            memcpy(bufD->ubuf.data(), u.data.constData(), u.data.size());
            bufD->ubufChangeRange = { 0, u.data.size() };
        } else {
            f->glBindBuffer(bufD->target, bufD->buffer);
            f->glBufferData(bufD->target, u.data.size(), u.data.constData(), GL_STATIC_DRAW);
        }
    }

    for (const QRhi::TextureUpload &u : updates.textureUploads) {
        // ###
    }
}

static inline GLenum toGlTopology(QRhiGraphicsPipeline::Topology t)
{
    switch (t) {
    case QRhiGraphicsPipeline::Triangles:
        return GL_TRIANGLES;
    case QRhiGraphicsPipeline::TriangleStrip:
        return GL_TRIANGLE_STRIP;
    case QRhiGraphicsPipeline::TriangleFan:
        return GL_TRIANGLE_FAN;
    case QRhiGraphicsPipeline::Lines:
        return GL_LINES;
    case QRhiGraphicsPipeline::LineStrip:
        return GL_LINE_STRIP;
    case QRhiGraphicsPipeline::Points:
        return GL_POINTS;
    default:
        Q_UNREACHABLE();
        return GL_TRIANGLES;
    }
}

static inline GLenum toGlCullMode(QRhiGraphicsPipeline::CullMode mode)
{
    if (mode.testFlag(QRhiGraphicsPipeline::Front)) {
        if (mode.testFlag(QRhiGraphicsPipeline::Back))
            return GL_FRONT_AND_BACK;
        return GL_FRONT;
    }
    return GL_BACK;
}

static inline GLenum toGlFrontFace(QRhiGraphicsPipeline::FrontFace f)
{
    switch (f) {
    case QRhiGraphicsPipeline::CCW:
        return GL_CCW;
    case QRhiGraphicsPipeline::CW:
        return GL_CW;
    default:
        Q_UNREACHABLE();
        return GL_CCW;
    }
}

static inline GLenum toGlBlendFactor(QRhiGraphicsPipeline::BlendFactor f)
{
    switch (f) {
    case QRhiGraphicsPipeline::Zero:
        return GL_ZERO;
    case QRhiGraphicsPipeline::One:
        return GL_ONE;
    case QRhiGraphicsPipeline::SrcColor:
        return GL_SRC_COLOR;
    case QRhiGraphicsPipeline::OneMinusSrcColor:
        return GL_ONE_MINUS_SRC_COLOR;
    case QRhiGraphicsPipeline::DstColor:
        return GL_DST_COLOR;
    case QRhiGraphicsPipeline::OneMinusDstColor:
        return GL_ONE_MINUS_DST_COLOR;
    case QRhiGraphicsPipeline::SrcAlpha:
        return GL_SRC_ALPHA;
    case QRhiGraphicsPipeline::OneMinusSrcAlpha:
        return GL_ONE_MINUS_SRC_ALPHA;
    case QRhiGraphicsPipeline::DstAlpha:
        return GL_DST_ALPHA;
    case QRhiGraphicsPipeline::OneMinusDstAlpha:
        return GL_ONE_MINUS_DST_ALPHA;
    case QRhiGraphicsPipeline::ConstantColor:
        return GL_CONSTANT_COLOR;
    case QRhiGraphicsPipeline::OneMinusConstantColor:
        return GL_ONE_MINUS_CONSTANT_COLOR;
    case QRhiGraphicsPipeline::ConstantAlpha:
        return GL_CONSTANT_ALPHA;
    case QRhiGraphicsPipeline::OneMinusConstantAlpha:
        return GL_ONE_MINUS_CONSTANT_ALPHA;
    case QRhiGraphicsPipeline::SrcAlphaSaturate:
        return GL_SRC_ALPHA_SATURATE;
    case QRhiGraphicsPipeline::Src1Color:
        Q_FALLTHROUGH();
    case QRhiGraphicsPipeline::OneMinusSrc1Color:
        Q_FALLTHROUGH();
    case QRhiGraphicsPipeline::Src1Alpha:
        Q_FALLTHROUGH();
    case QRhiGraphicsPipeline::OneMinusSrc1Alpha:
        qWarning("Unsupported blend factor %x", f);
        return GL_ZERO;
    default:
        Q_UNREACHABLE();
        return GL_ZERO;
    }
}

static inline GLenum toGlBlendOp(QRhiGraphicsPipeline::BlendOp op)
{
    switch (op) {
    case QRhiGraphicsPipeline::Add:
        return GL_ADD;
    case QRhiGraphicsPipeline::Subtract:
        return GL_SUBTRACT;
    case QRhiGraphicsPipeline::ReverseSubtract:
        return GL_FUNC_REVERSE_SUBTRACT;
    case QRhiGraphicsPipeline::Min:
        return GL_MIN;
    case QRhiGraphicsPipeline::Max:
        return GL_MAX;
    default:
        Q_UNREACHABLE();
        return GL_ADD;
    }
}

static inline GLenum toGlCompareOp(QRhiGraphicsPipeline::CompareOp op)
{
    switch (op) {
    case QRhiGraphicsPipeline::Never:
        return GL_NEVER;
    case QRhiGraphicsPipeline::Less:
        return GL_LESS;
    case QRhiGraphicsPipeline::Equal:
        return GL_EQUAL;
    case QRhiGraphicsPipeline::LessOrEqual:
        return GL_LEQUAL;
    case QRhiGraphicsPipeline::Greater:
        return GL_GREATER;
    case QRhiGraphicsPipeline::NotEqual:
        return GL_NOTEQUAL;
    case QRhiGraphicsPipeline::GreaterOrEqual:
        return GL_GEQUAL;
    case QRhiGraphicsPipeline::Always:
        return GL_ALWAYS;
    default:
        Q_UNREACHABLE();
        return GL_ALWAYS;
    }
}

static inline GLenum toGlStencilOp(QRhiGraphicsPipeline::StencilOp op)
{
    switch (op) {
    case QRhiGraphicsPipeline::StencilZero:
        return GL_ZERO;
    case QRhiGraphicsPipeline::Keep:
        return GL_KEEP;
    case QRhiGraphicsPipeline::Replace:
        return GL_REPLACE;
    case QRhiGraphicsPipeline::IncrementAndClamp:
        return GL_INCR;
    case QRhiGraphicsPipeline::DecrementAndClamp:
        return GL_DECR;
    case QRhiGraphicsPipeline::Invert:
        return GL_INVERT;
    case QRhiGraphicsPipeline::IncrementAndWrap:
        return GL_INCR_WRAP;
    case QRhiGraphicsPipeline::DecrementAndWrap:
        return GL_DECR_WRAP;
    default:
        Q_UNREACHABLE();
        return GL_KEEP;
    }
}

void QRhiGles2::executeCommandBuffer(QRhiCommandBuffer *cb)
{
    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);
    GLenum indexType = GL_UNSIGNED_SHORT;
    size_t indexStride = sizeof(quint16);

    for (const QGles2CommandBuffer::Command &cmd : qAsConst(cbD->commands)) {
        switch (cmd.cmd) {
        case QGles2CommandBuffer::Command::Viewport:
            f->glViewport(cmd.args.viewport.x, cmd.args.viewport.y, cmd.args.viewport.w, cmd.args.viewport.h);
            f->glDepthRangef(cmd.args.viewport.d0, cmd.args.viewport.d1);
            break;
        case QGles2CommandBuffer::Command::Scissor:
            f->glScissor(cmd.args.scissor.x, cmd.args.scissor.y, cmd.args.scissor.w, cmd.args.scissor.h);
            break;
        case QGles2CommandBuffer::Command::BlendConstants:
            f->glBlendColor(cmd.args.blendConstants.r, cmd.args.blendConstants.g, cmd.args.blendConstants.b, cmd.args.blendConstants.a);
            break;
        case QGles2CommandBuffer::Command::StencilRef:
        {
            QGles2GraphicsPipeline *ps = QRHI_RES(QGles2GraphicsPipeline, cmd.args.stencilRef.ps);
            if (ps) {
                f->glStencilFuncSeparate(GL_FRONT, toGlCompareOp(ps->stencilFront.compareOp), cmd.args.stencilRef.ref, ps->stencilReadMask);
                f->glStencilFuncSeparate(GL_BACK, toGlCompareOp(ps->stencilBack.compareOp), cmd.args.stencilRef.ref, ps->stencilReadMask);
            } else {
                qWarning("No graphics pipeline active for setStencilRef; ignored");
            }
        }
            break;
        case QGles2CommandBuffer::Command::BindVertexBuffer:
        {
            QGles2GraphicsPipeline *ps = QRHI_RES(QGles2GraphicsPipeline, cmd.args.bindVertexBuffer.ps);
            if (ps) {
                for (const QRhiVertexInputLayout::Attribute &a : ps->vertexInputLayout.attributes) {
                    if (a.binding != cmd.args.bindVertexBuffer.binding)
                        continue;

                    // we do not support more than one vertex buffer
                    f->glBindBuffer(GL_ARRAY_BUFFER, cmd.args.bindVertexBuffer.buffer);

                    const int stride = ps->vertexInputLayout.bindings[a.binding].stride;
                    int size = 1;
                    GLenum type = GL_FLOAT;
                    switch (a.format) {
                    case QRhiVertexInputLayout::Attribute::Float4:
                        type = GL_FLOAT;
                        size = 4;
                        break;
                    case QRhiVertexInputLayout::Attribute::Float3:
                        type = GL_FLOAT;
                        size = 3;
                        break;
                    case QRhiVertexInputLayout::Attribute::Float2:
                        type = GL_FLOAT;
                        size = 2;
                        break;
                    case QRhiVertexInputLayout::Attribute::Float:
                        type = GL_FLOAT;
                        size = 1;
                        break;
                    case QRhiVertexInputLayout::Attribute::UNormByte4:
                        type = GL_UNSIGNED_BYTE;
                        size = 4;
                        break;
                    case QRhiVertexInputLayout::Attribute::UNormByte2:
                        type = GL_UNSIGNED_BYTE;
                        size = 2;
                        break;
                    case QRhiVertexInputLayout::Attribute::UNormByte:
                        type = GL_UNSIGNED_BYTE;
                        size = 1;
                        break;
                    default:
                        break;
                    }
                    f->glVertexAttribPointer(a.location, size, type, GL_FALSE, stride,
                                             reinterpret_cast<const GLvoid *>(quintptr(a.offset)));
                    f->glEnableVertexAttribArray(a.location);
                }
            } else {
                qWarning("No graphics pipeline active for setVertexInput; ignored");
            }
        }
            break;
        case QGles2CommandBuffer::Command::BindIndexBuffer:
            indexType = cmd.args.bindIndexBuffer.type;
            indexStride = indexType == GL_UNSIGNED_SHORT ? sizeof(quint16) : sizeof(quint32);
            f->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, cmd.args.bindIndexBuffer.buffer);
            break;
        case QGles2CommandBuffer::Command::Draw:
        {
            QGles2GraphicsPipeline *ps = QRHI_RES(QGles2GraphicsPipeline, cmd.args.draw.ps);
            if (ps)
                f->glDrawArrays(ps->drawMode, cmd.args.draw.firstVertex, cmd.args.draw.vertexCount);
            else
                qWarning("No graphics pipeline active for draw; ignored");
        }
            break;
        case QGles2CommandBuffer::Command::DrawIndexed:
        {
            QGles2GraphicsPipeline *ps = QRHI_RES(QGles2GraphicsPipeline, cmd.args.drawIndexed.ps);
            if (ps) {
                f->glDrawElements(ps->drawMode,
                                  cmd.args.drawIndexed.indexCount,
                                  indexType,
                                  reinterpret_cast<const GLvoid *>(quintptr(cmd.args.drawIndexed.firstIndex * indexStride)));
            } else {
                qWarning("No graphics pipeline active for drawIndexed; ignored");
            }
        }
            break;
        case QGles2CommandBuffer::Command::BindGraphicsPipeline:
            executeBindGraphicsPipeline(cmd.args.bindGraphicsPipeline.ps, cmd.args.bindGraphicsPipeline.srb);
            break;
        default:
            break;
        }
    }
}

void QRhiGles2::executeBindGraphicsPipeline(QRhiGraphicsPipeline *ps, QRhiShaderResourceBindings *srb)
{
    QGles2GraphicsPipeline *psD = QRHI_RES(QGles2GraphicsPipeline, ps);

    // ### this needs some proper caching later on to minimize state changes
    f->glCullFace(toGlCullMode(ps->cullMode));
    f->glFrontFace(toGlFrontFace(ps->frontFace));
    if (!ps->targetBlends.isEmpty()) {
        const QRhiGraphicsPipeline::TargetBlend &blend(ps->targetBlends.first()); // no MRT
        GLboolean wr = blend.colorWrite.testFlag(QRhiGraphicsPipeline::R);
        GLboolean wg = blend.colorWrite.testFlag(QRhiGraphicsPipeline::G);
        GLboolean wb = blend.colorWrite.testFlag(QRhiGraphicsPipeline::B);
        GLboolean wa = blend.colorWrite.testFlag(QRhiGraphicsPipeline::A);
        f->glColorMask(wr, wg, wb, wa);
        if (blend.enable) {
            f->glEnable(GL_BLEND);
            f->glBlendFuncSeparate(toGlBlendFactor(blend.srcColor),
                                   toGlBlendFactor(blend.dstColor),
                                   toGlBlendFactor(blend.srcAlpha),
                                   toGlBlendFactor(blend.dstAlpha));
            f->glBlendEquationSeparate(toGlBlendOp(blend.opColor), toGlBlendOp(blend.opAlpha));
        } else {
            f->glDisable(GL_BLEND);
        }
    }
    if (ps->depthTest)
        f->glEnable(GL_DEPTH_TEST);
    else
        f->glDisable(GL_DEPTH_TEST);
    if (ps->depthWrite)
        f->glDepthMask(GL_TRUE);
    else
        f->glDepthMask(GL_FALSE);
    f->glDepthFunc(toGlCompareOp(ps->depthOp));
    if (ps->stencilTest) {
        f->glEnable(GL_STENCIL_TEST);
        f->glStencilFuncSeparate(GL_FRONT, toGlCompareOp(ps->stencilFront.compareOp), 0, ps->stencilReadMask);
        f->glStencilOpSeparate(GL_FRONT,
                               toGlStencilOp(ps->stencilFront.failOp),
                               toGlStencilOp(ps->stencilFront.depthFailOp),
                               toGlStencilOp(ps->stencilFront.passOp));
        f->glStencilMaskSeparate(GL_FRONT, ps->stencilWriteMask);
        f->glStencilFuncSeparate(GL_BACK, toGlCompareOp(ps->stencilBack.compareOp), 0, ps->stencilReadMask);
        f->glStencilOpSeparate(GL_BACK,
                               toGlStencilOp(ps->stencilBack.failOp),
                               toGlStencilOp(ps->stencilBack.depthFailOp),
                               toGlStencilOp(ps->stencilBack.passOp));
        f->glStencilMaskSeparate(GL_BACK, ps->stencilWriteMask);
    } else {
        f->glDisable(GL_STENCIL_TEST);
    }

    f->glUseProgram(psD->program);
    // buffer data cannot change within the pass so this time is as good to update uniforms as any
    setChangedUniforms(psD, srb);
}

void QRhiGles2::setChangedUniforms(QGles2GraphicsPipeline *psD, QRhiShaderResourceBindings *srb)
{
    for (int i = 0, ie = srb->bindings.count(); i != ie; ++i) {
        const QRhiShaderResourceBindings::Binding &b(srb->bindings[i]);
        switch (b.type) {
        case QRhiShaderResourceBindings::Binding::UniformBuffer:
        {
            QGles2Buffer *bufD = QRHI_RES(QGles2Buffer, b.ubuf.buf);
            if (bufD->ubufChangeRange.isNull()) // do not set again when nothing changed
                break;
            const QByteArray bufView = QByteArray::fromRawData(bufD->ubuf.constData() + b.ubuf.offset, b.ubuf.size);
            for (QGles2GraphicsPipeline::Uniform &uniform : psD->uniforms) {
                if (uniform.binding == b.binding
                        && uniform.offset >= uint(bufD->ubufChangeRange.changeBegin)
                        && uniform.offset < uint(bufD->ubufChangeRange.changeEnd))
                {
                    memcpy(uniform.data.data(), bufView.constData() + uniform.offset, uniform.data.size());

                    switch (uniform.type) {
                    case QShaderDescription::Float:
                        f->glUniform1f(uniform.location, *reinterpret_cast<const float *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Vec2:
                        f->glUniform2fv(uniform.location, 1, reinterpret_cast<const float *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Vec3:
                        f->glUniform3fv(uniform.location, 1, reinterpret_cast<const float *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Vec4:
                        f->glUniform4fv(uniform.location, 1, reinterpret_cast<const float *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Mat2:
                        f->glUniformMatrix2fv(uniform.location, 1, GL_FALSE, reinterpret_cast<const float *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Mat3:
                        f->glUniformMatrix3fv(uniform.location, 1, GL_FALSE, reinterpret_cast<const float *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Mat4:
                        f->glUniformMatrix4fv(uniform.location, 1, GL_FALSE, reinterpret_cast<const float *>(uniform.data.constData()));
                        break;
                        // ### more types
                    default:
                        break;
                    }
                }
            }

            bufD->ubufChangeRange = QGles2Buffer::ChangeRange();
        }
            break;
        case QRhiShaderResourceBindings::Binding::SampledTexture:
            // ###
            break;
        default:
            Q_UNREACHABLE();
            break;
        }
    }
}

void QRhiGles2::beginPass(QRhiRenderTarget *rt, QRhiCommandBuffer *cb, const QRhiClearValue *clearValues, const QRhi::PassUpdates &updates)
{
    Q_ASSERT(!inPass);

    applyPassUpdates(cb, updates);

    bool needsColorClear = true;
    QGles2BasicRenderTargetData *rtD = nullptr;
    switch (rt->type()) {
    case QRhiRenderTarget::RtRef:
        rtD = &static_cast<QGles2ReferenceRenderTarget *>(rt)->d;
        break;
    case QRhiRenderTarget::RtTexture:
    {
        QGles2TextureRenderTarget *rtTex = static_cast<QGles2TextureRenderTarget *>(rt);
        rtD = &rtTex->d;
        needsColorClear = !rtTex->flags.testFlag(QRhiTextureRenderTarget::PreserveColorContents);
        // ### activateTextureRenderTarget(cb, rtTex);
    }
        break;
    default:
        Q_UNREACHABLE();
        break;
    }

    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);
    cbD->currentTarget = rt;

    GLbitfield clearMask = GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT;
    if (needsColorClear) {
        clearMask |= GL_COLOR_BUFFER_BIT;
        const QVector4D &c(clearValues->rgba);
        f->glClearColor(c.x(), c.y(), c.z(), c.w());
    }
    f->glClear(clearMask);

    inPass = true;
}

void QRhiGles2::endPass(QRhiCommandBuffer *cb)
{
    Q_ASSERT(inPass);
    inPass = false;

    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);
    if (cbD->currentTarget->type() == QRhiRenderTarget::RtTexture)
    {}
        // ### deactivateTextureRenderTarget(cb, static_cast<QRhiTextureRenderTarget *>(cbD->currentTarget));

    cbD->currentTarget = nullptr;
}

QGles2Buffer::QGles2Buffer(QRhiImplementation *rhi, Type type, UsageFlags usage, int size)
    : QRhiBuffer(rhi, type, usage, size)
{
}

void QGles2Buffer::release()
{
    if (!buffer)
        return;

    QRhiGles2::DeferredReleaseEntry e;
    e.type = QRhiGles2::DeferredReleaseEntry::Buffer;

    e.buffer.buffer = buffer;

    buffer = 0;

    QRHI_RES_RHI(QRhiGles2);
    rhiD->releaseQueue.append(e);
}

bool QGles2Buffer::build()
{
    QRHI_RES_RHI(QRhiGles2);

    if (buffer)
        release();

    if (usage.testFlag(QRhiBuffer::UniformBuffer)) {
        // special since we do not support uniform blocks in this backend
        ubuf.resize(size);
        return true;
    }

    rhiD->ensureContext();

    if (usage.testFlag(QRhiBuffer::VertexBuffer))
        target = GL_ARRAY_BUFFER;
    if (usage.testFlag(QRhiBuffer::IndexBuffer))
        target = GL_ELEMENT_ARRAY_BUFFER;

    rhiD->f->glGenBuffers(1, &buffer);
    rhiD->f->glBindBuffer(target, buffer);
    rhiD->f->glBufferData(target, size, nullptr, isStatic() ? GL_STATIC_DRAW : GL_DYNAMIC_DRAW);

    return true;
}

QGles2RenderBuffer::QGles2RenderBuffer(QRhiImplementation *rhi, Type type, const QSize &pixelSize, int sampleCount)
    : QRhiRenderBuffer(rhi, type, pixelSize, sampleCount)
{
}

void QGles2RenderBuffer::release()
{
}

bool QGles2RenderBuffer::build()
{
    return true;
}

QGles2Texture::QGles2Texture(QRhiImplementation *rhi, Format format, const QSize &pixelSize, Flags flags)
    : QRhiTexture(rhi, format, pixelSize, flags)
{
}

static inline QSize safeSize(const QSize &size)
{
    return size.isEmpty() ? QSize(16, 16) : size;
}

void QGles2Texture::release()
{
    if (!texture)
        return;

    QRhiGles2::DeferredReleaseEntry e;
    e.type = QRhiGles2::DeferredReleaseEntry::Texture;

    e.texture.texture = texture;

    texture = 0;

    QRHI_RES_RHI(QRhiGles2);
    rhiD->releaseQueue.append(e);
}

bool QGles2Texture::build()
{
    QRHI_RES_RHI(QRhiGles2);

    if (texture)
        release();

    rhiD->f->glGenTextures(1, &texture);
    rhiD->f->glBindTexture(GL_TEXTURE_2D, texture);

    const QSize size = safeSize(pixelSize);
    GLenum glintformat;
    GLenum glformat;
    GLenum gltype;
    switch (format) {
    case QRhiTexture::RGBA8:
        Q_FALLTHROUGH();
    default:
        glintformat = GL_RGBA;
        glformat = GL_RGBA;
        gltype = GL_UNSIGNED_BYTE;
        break;
    // ###
    }

    rhiD->f->glTexImage2D(GL_TEXTURE_2D, 0, glintformat, size.width(), size.height(), 0, glformat, gltype, nullptr);

    return true;
}

QGles2Sampler::QGles2Sampler(QRhiImplementation *rhi, Filter magFilter, Filter minFilter, Filter mipmapMode, AddressMode u, AddressMode v)
    : QRhiSampler(rhi, magFilter, minFilter, mipmapMode, u, v)
{
}

void QGles2Sampler::release()
{
}

bool QGles2Sampler::build()
{
    return true;
}

QGles2RenderPass::QGles2RenderPass(QRhiImplementation *rhi)
    : QRhiRenderPass(rhi)
{
}

void QGles2RenderPass::release()
{
}

QGles2ReferenceRenderTarget::QGles2ReferenceRenderTarget(QRhiImplementation *rhi)
    : QRhiReferenceRenderTarget(rhi),
      d(rhi)
{
}

void QGles2ReferenceRenderTarget::release()
{
    // nothing to do here
}

QRhiRenderTarget::Type QGles2ReferenceRenderTarget::type() const
{
    return RtRef;
}

QSize QGles2ReferenceRenderTarget::sizeInPixels() const
{
    return d.pixelSize;
}

const QRhiRenderPass *QGles2ReferenceRenderTarget::renderPass() const
{
    return &d.rp;
}

QGles2TextureRenderTarget::QGles2TextureRenderTarget(QRhiImplementation *rhi, QRhiTexture *texture, Flags flags)
    : QRhiTextureRenderTarget(rhi, texture, flags),
      d(rhi)
{
}

QGles2TextureRenderTarget::QGles2TextureRenderTarget(QRhiImplementation *rhi, QRhiTexture *texture, QRhiRenderBuffer *depthStencilBuffer, Flags flags)
    : QRhiTextureRenderTarget(rhi, texture, depthStencilBuffer, flags),
      d(rhi)
{
}

QGles2TextureRenderTarget::QGles2TextureRenderTarget(QRhiImplementation *rhi, QRhiTexture *texture, QRhiTexture *depthTexture, Flags flags)
    : QRhiTextureRenderTarget(rhi, texture, depthTexture, flags),
      d(rhi)
{
}

void QGles2TextureRenderTarget::release()
{
}

bool QGles2TextureRenderTarget::build()
{
    return true;
}

QRhiRenderTarget::Type QGles2TextureRenderTarget::type() const
{
    return RtTexture;
}

QSize QGles2TextureRenderTarget::sizeInPixels() const
{
    return d.pixelSize;
}

const QRhiRenderPass *QGles2TextureRenderTarget::renderPass() const
{
    return &d.rp;
}

QGles2ShaderResourceBindings::QGles2ShaderResourceBindings(QRhiImplementation *rhi)
    : QRhiShaderResourceBindings(rhi)
{
}

void QGles2ShaderResourceBindings::release()
{
    // nothing to do here
}

bool QGles2ShaderResourceBindings::build()
{
    // deeply complex implementation
    return true;
}

QGles2GraphicsPipeline::QGles2GraphicsPipeline(QRhiImplementation *rhi)
    : QRhiGraphicsPipeline(rhi)
{
}

void QGles2GraphicsPipeline::release()
{
    if (!program)
        return;

    QRhiGles2::DeferredReleaseEntry e;
    e.type = QRhiGles2::DeferredReleaseEntry::Pipeline;

    e.pipeline.program = program;

    program = 0;
    uniforms.clear();

    QRHI_RES_RHI(QRhiGles2);
    rhiD->releaseQueue.append(e);
}

bool QGles2GraphicsPipeline::build()
{
    QRHI_RES_RHI(QRhiGles2);

    if (program)
        release();

    drawMode = toGlTopology(topology);

    program = rhiD->f->glCreateProgram();

    for (const QRhiGraphicsShaderStage &shaderStage : qAsConst(shaderStages)) {
        const bool isVertex = shaderStage.type == QRhiGraphicsShaderStage::Vertex;
        const bool isFragment = shaderStage.type == QRhiGraphicsShaderStage::Fragment;
        if (!isVertex && !isFragment)
            continue;

        GLuint shader = rhiD->f->glCreateShader(isVertex ? GL_VERTEX_SHADER : GL_FRAGMENT_SHADER);
        const QByteArray source = shaderStage.shader.shader({ QBakedShader::GlslShader,
                                                              { 100, QBakedShader::ShaderSourceVersion::GlslEs } }).shader;
        if (source.isEmpty()) {
            qWarning() << "No GLSL ES 100 shader code found in baked shader" << shaderStage.shader;
            return false;
        }
        const char *srcStr = source.constData();
        const GLint srcLength = source.count();
        rhiD->f->glShaderSource(shader, 1, &srcStr, &srcLength);
        rhiD->f->glCompileShader(shader);
        GLint compiled = 0;
        rhiD->f->glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
        if (!compiled) {
            GLint infoLogLength = 0;
            rhiD->f->glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLogLength);
            QByteArray log;
            if (infoLogLength > 1) {
                GLsizei length = 0;
                log.resize(infoLogLength);
                rhiD->f->glGetShaderInfoLog(shader, infoLogLength, &length, log.data());
            }
            qWarning("Failed to compile shader: %s\nSource was:\n%s", log.constData(), source.constData());
            return false;
        }

        rhiD->f->glAttachShader(program, shader);
        rhiD->f->glDeleteShader(shader);

        if (isVertex)
            vsDesc = shaderStage.shader.description();
        else
            fsDesc = shaderStage.shader.description();
    }

    for (auto inVar : vsDesc.inputVariables()) {
        const QByteArray name = inVar.name.toUtf8();
        rhiD->f->glBindAttribLocation(program, inVar.location, name.constData());
    }

    rhiD->f->glLinkProgram(program);
    GLint linked = 0;
    rhiD->f->glGetProgramiv(program, GL_LINK_STATUS, &linked);
    if (!linked) {
        GLint infoLogLength = 0;
        rhiD->f->glGetProgramiv(program, GL_INFO_LOG_LENGTH, &infoLogLength);
        QByteArray log;
        if (infoLogLength > 1) {
            GLsizei length = 0;
            log.resize(infoLogLength);
            rhiD->f->glGetProgramInfoLog(program, infoLogLength, &length, log.data());
        }
        qWarning("Failed to link shader program: %s", log.constData());
        return false;
    }

    auto lookupUniforms = [this, rhiD](const QShaderDescription::UniformBlock &ub) {
        const QByteArray prefix = ub.structName.toUtf8() + '.';
        for (const QShaderDescription::BlockVariable &blockMember : ub.members) {
            // ### no array support for now
            Uniform uniform;
            uniform.type = blockMember.type;
            const QByteArray name = prefix + blockMember.name.toUtf8();
            uniform.location = rhiD->f->glGetUniformLocation(program, name.constData());
            if (uniform.location >= 0) {
                uniform.binding = ub.binding;
                uniform.offset = blockMember.offset;
                uniform.data.resize(blockMember.size);
                uniforms.append(uniform);
            }
        }
    };

    for (const QShaderDescription::UniformBlock &ub : vsDesc.uniformBlocks())
        lookupUniforms(ub);

    for (const QShaderDescription::UniformBlock &ub : fsDesc.uniformBlocks())
        lookupUniforms(ub);

    generation += 1;
    return true;
}

QGles2CommandBuffer::QGles2CommandBuffer(QRhiImplementation *rhi)
    : QRhiCommandBuffer(rhi)
{
    resetState();
}

void QGles2CommandBuffer::release()
{
    Q_UNREACHABLE();
}

QGles2SwapChain::QGles2SwapChain(QRhiImplementation *rhi)
    : QRhiSwapChain(rhi),
      rt(rhi),
      cb(rhi)
{
}

void QGles2SwapChain::release()
{
}

QRhiCommandBuffer *QGles2SwapChain::currentFrameCommandBuffer()
{
    return &cb;
}

QRhiRenderTarget *QGles2SwapChain::currentFrameRenderTarget()
{
    return &rt;
}

const QRhiRenderPass *QGles2SwapChain::defaultRenderPass() const
{
    return rt.renderPass();
}

QSize QGles2SwapChain::sizeInPixels() const
{
    return pixelSize;
}

bool QGles2SwapChain::build(QWindow *window, const QSize &pixelSize_, SurfaceImportFlags flags,
                            QRhiRenderBuffer *depthStencil, int sampleCount_)
{
    Q_UNUSED(flags);
    Q_UNUSED(depthStencil);
    Q_UNUSED(sampleCount_);

    surface = window;
    pixelSize = pixelSize_;
    QRHI_RES(QGles2ReferenceRenderTarget, &rt)->d.pixelSize = pixelSize_;

    return true;
}

bool QGles2SwapChain::build(QObject *target)
{
    // ### some day this could support QOpenGLWindow, OpenGLWidget, ...
    Q_UNUSED(target);
    return false;
}

QT_END_NAMESPACE
