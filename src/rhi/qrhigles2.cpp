/****************************************************************************
**
** Copyright (C) 2018 The Qt Company Ltd.
** Contact: http://www.qt.io/licensing/
**
** This file is part of the Qt RHI module
**
** $QT_BEGIN_LICENSE:LGPL3$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see http://www.qt.io/terms-conditions. For further
** information use the contact form at http://www.qt.io/contact-us.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 3 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPLv3 included in the
** packaging of this file. Please review the following information to
** ensure the GNU Lesser General Public License version 3 requirements
** will be met: https://www.gnu.org/licenses/lgpl.html.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 2.0 or later as published by the Free
** Software Foundation and appearing in the file LICENSE.GPL included in
** the packaging of this file. Please review the following information to
** ensure the GNU General Public License version 2.0 requirements will be
** met: http://www.gnu.org/licenses/gpl-2.0.html.
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include "qrhigles2_p.h"
#include <QWindow>
#include <QOffscreenSurface>
#include <QOpenGLContext>
#include <qmath.h>

QT_BEGIN_NAMESPACE

/*
  OpenGL ES 2.0 + GLSL 100/120 backend. Binding vertex attribute locations and
  decomposing uniform buffers into uniforms (as expected by the GLSL 1xx shader
  generated by SPIRV-Cross) are handled transparently to the application via
  the reflection data (QShaderDescription). Textures and buffers feature no
  special logic, it's all just glTexSubImage2D and glBufferSubData (with
  "dynamic" buffers set to GL_DYNAMIC_DRAW). The swapchain and the associated
  renderbuffer for depth-stencil will be dummies since we have no control over
  the underlying buffers here. It is up to the application to create the
  context and window with the appropriate QSurfaceFormat when it comes to
  depth/stencil and MSAA.
*/

QRhiGles2::QRhiGles2(QRhiInitParams *params)
{
    QRhiGles2InitParams *glparams = static_cast<QRhiGles2InitParams *>(params);
    ctx = glparams->context;
    maybeWindow = glparams->window; // may be null
    fallbackSurface = glparams->fallbackSurface;

    create();
}

QRhiGles2::~QRhiGles2()
{
    destroy();
}

void QRhiGles2::ensureContext(QSurface *surface)
{
    bool nativeWindowGone = false;
    if (surface && surface->surfaceClass() == QSurface::Window && !surface->surfaceHandle()) {
        surface = fallbackSurface;
        nativeWindowGone = true;
    }

    if (!surface)
        surface = fallbackSurface;

    if (buffersSwapped)
        buffersSwapped = false;
    else if (!nativeWindowGone && QOpenGLContext::currentContext() == ctx && (surface == fallbackSurface || ctx->surface() == surface))
        return;

    if (!ctx->makeCurrent(surface))
        qWarning("QRhiGles2: Failed to make context current. Expect bad things to happen.");
}

void QRhiGles2::create()
{
    Q_ASSERT(ctx);
    Q_ASSERT(fallbackSurface);

    ensureContext(maybeWindow ? maybeWindow : fallbackSurface); // see 'window' discussion in QRhiGles2InitParams comments

    f = ctx->functions();

    const char *vendor = reinterpret_cast<const char *>(f->glGetString(GL_VENDOR));
    const char *renderer = reinterpret_cast<const char *>(f->glGetString(GL_RENDERER));
    const char *version = reinterpret_cast<const char *>(f->glGetString(GL_VERSION));
    if (vendor && renderer && version)
        qDebug("OpenGL VENDOR: %s RENDERER: %s VERSION: %s", vendor, renderer, version);
}

void QRhiGles2::destroy()
{
    if (!f)
        return;

    ensureContext();
    executeDeferredReleases();

    f = nullptr;
}

// Strictly speaking this is not necessary since we could do the deletes in
// release(). However, it is kind of nice that no release() ever requires a
// current context and so GL calls are isolated to specific places (build,
// beginFrame, endFrame) as much as possible.
void QRhiGles2::executeDeferredReleases()
{
    for (int i = releaseQueue.count() - 1; i >= 0; --i) {
        const QRhiGles2::DeferredReleaseEntry &e(releaseQueue[i]);
        switch (e.type) {
        case QRhiGles2::DeferredReleaseEntry::Buffer:
            f->glDeleteBuffers(1, &e.buffer.buffer);
            break;
        case QRhiGles2::DeferredReleaseEntry::Pipeline:
            f->glDeleteProgram(e.pipeline.program);
            break;
        case QRhiGles2::DeferredReleaseEntry::Texture:
            f->glDeleteTextures(1, &e.texture.texture);
            break;
        case QRhiGles2::DeferredReleaseEntry::RenderBuffer:
            f->glDeleteRenderbuffers(1, &e.renderbuffer.renderbuffer);
            break;
        case QRhiGles2::DeferredReleaseEntry::TextureRenderTarget:
            f->glDeleteFramebuffers(1, &e.textureRenderTarget.framebuffer);
            break;
        default:
            break;
        }
        releaseQueue.removeAt(i);
    }
}

QVector<int> QRhiGles2::supportedSampleCounts() const
{
    return { 1 };
}

QRhiSwapChain *QRhiGles2::createSwapChain()
{
    return new QGles2SwapChain(this);
}

QRhiBuffer *QRhiGles2::createBuffer(QRhiBuffer::Type type, QRhiBuffer::UsageFlags usage, int size)
{
    return new QGles2Buffer(this, type, usage, size);
}

int QRhiGles2::ubufAlignment() const
{
    return 256;
}

bool QRhiGles2::isYUpInFramebuffer() const
{
    return true;
}

QMatrix4x4 QRhiGles2::clipSpaceCorrMatrix() const
{
    return QMatrix4x4(); // identity
}

QRhiRenderBuffer *QRhiGles2::createRenderBuffer(QRhiRenderBuffer::Type type, const QSize &pixelSize,
                                                int sampleCount, QRhiRenderBuffer::Hints hints)
{
    return new QGles2RenderBuffer(this, type, pixelSize, sampleCount, hints);
}

QRhiTexture *QRhiGles2::createTexture(QRhiTexture::Format format, const QSize &pixelSize, QRhiTexture::Flags flags)
{
    return new QGles2Texture(this, format, pixelSize, flags);
}

QRhiSampler *QRhiGles2::createSampler(QRhiSampler::Filter magFilter, QRhiSampler::Filter minFilter,
                                      QRhiSampler::Filter mipmapMode,
                                      QRhiSampler::AddressMode u, QRhiSampler::AddressMode v, QRhiSampler::AddressMode w)
{
    return new QGles2Sampler(this, magFilter, minFilter, mipmapMode, u, v, w);
}

QRhiTextureRenderTarget *QRhiGles2::createTextureRenderTarget(QRhiTexture *texture,
                                                              QRhiTextureRenderTarget::Flags flags)
{
    return new QGles2TextureRenderTarget(this, texture, flags);
}

QRhiTextureRenderTarget *QRhiGles2::createTextureRenderTarget(QRhiTexture *texture,
                                                              QRhiRenderBuffer *depthStencilBuffer,
                                                              QRhiTextureRenderTarget::Flags flags)
{
    return new QGles2TextureRenderTarget(this, texture, depthStencilBuffer, flags);
}

QRhiTextureRenderTarget *QRhiGles2::createTextureRenderTarget(QRhiTexture *texture,
                                                              QRhiTexture *depthTexture,
                                                              QRhiTextureRenderTarget::Flags flags)
{
    return new QGles2TextureRenderTarget(this, texture, depthTexture, flags);
}

QRhiGraphicsPipeline *QRhiGles2::createGraphicsPipeline()
{
    return new QGles2GraphicsPipeline(this);
}

QRhiShaderResourceBindings *QRhiGles2::createShaderResourceBindings()
{
    return new QGles2ShaderResourceBindings(this);
}

void QRhiGles2::setGraphicsPipeline(QRhiCommandBuffer *cb, QRhiGraphicsPipeline *ps, QRhiShaderResourceBindings *srb)
{
    Q_ASSERT(inPass);

    if (!srb)
        srb = ps->shaderResourceBindings;

    QGles2GraphicsPipeline *psD = QRHI_RES(QGles2GraphicsPipeline, ps);
    QGles2ShaderResourceBindings *srbD = QRHI_RES(QGles2ShaderResourceBindings, srb);
    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);

    const bool pipelineChanged = cbD->currentPipeline != ps || cbD->currentPipelineGeneration != psD->generation;
    const bool srbChanged = cbD->currentSrb != srb || cbD->currentSrbGeneration != srbD->generation;

    if (pipelineChanged || srbChanged) {
        cbD->currentPipeline = ps;
        cbD->currentPipelineGeneration = psD->generation;
        cbD->currentSrb = srb;
        cbD->currentSrbGeneration = srbD->generation;

        QGles2CommandBuffer::Command cmd;
        cmd.cmd = QGles2CommandBuffer::Command::BindGraphicsPipeline;
        cmd.args.bindGraphicsPipeline.ps = ps;
        cmd.args.bindGraphicsPipeline.srb = srb;
        cmd.args.bindGraphicsPipeline.resOnlyChange = !pipelineChanged && srbChanged;
        cbD->commands.append(cmd);
    }
}

void QRhiGles2::setVertexInput(QRhiCommandBuffer *cb, int startBinding, const QVector<QRhi::VertexInput> &bindings,
                               QRhiBuffer *indexBuf, quint32 indexOffset, QRhi::IndexFormat indexFormat)
{
    Q_ASSERT(inPass);
    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);

    for (int i = 0, ie = bindings.count(); i != ie; ++i) {
        QRhiBuffer *buf = bindings[i].first;
        quint32 ofs = bindings[i].second;
        QGles2Buffer *bufD = QRHI_RES(QGles2Buffer, buf);
        Q_ASSERT(buf->usage.testFlag(QRhiBuffer::VertexBuffer));
        QGles2CommandBuffer::Command cmd;
        cmd.cmd = QGles2CommandBuffer::Command::BindVertexBuffer;
        cmd.args.bindVertexBuffer.ps = cbD->currentPipeline;
        cmd.args.bindVertexBuffer.buffer = bufD->buffer;
        cmd.args.bindVertexBuffer.offset = ofs;
        cmd.args.bindVertexBuffer.binding = startBinding + i;
        cbD->commands.append(cmd);
    }

    if (indexBuf) {
        QGles2Buffer *ibufD = QRHI_RES(QGles2Buffer, indexBuf);
        Q_ASSERT(indexBuf->usage.testFlag(QRhiBuffer::IndexBuffer));
        QGles2CommandBuffer::Command cmd;
        cmd.cmd = QGles2CommandBuffer::Command::BindIndexBuffer;
        cmd.args.bindIndexBuffer.buffer = ibufD->buffer;
        cmd.args.bindIndexBuffer.offset = indexOffset;
        cmd.args.bindIndexBuffer.type = indexFormat == QRhi::IndexUInt16 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT;
        cbD->commands.append(cmd);
    }
}

void QRhiGles2::setViewport(QRhiCommandBuffer *cb, const QRhiViewport &viewport)
{
    Q_ASSERT(inPass);
    QGles2CommandBuffer::Command cmd;
    cmd.cmd = QGles2CommandBuffer::Command::Viewport;
    cmd.args.viewport.x = viewport.r.x();
    cmd.args.viewport.y = viewport.r.y();
    cmd.args.viewport.w = viewport.r.z();
    cmd.args.viewport.h = viewport.r.w();
    cmd.args.viewport.d0 = viewport.minDepth;
    cmd.args.viewport.d1 = viewport.maxDepth;
    QRHI_RES(QGles2CommandBuffer, cb)->commands.append(cmd);
}

void QRhiGles2::setScissor(QRhiCommandBuffer *cb, const QRhiScissor &scissor)
{
    Q_ASSERT(inPass);
    QGles2CommandBuffer::Command cmd;
    cmd.cmd = QGles2CommandBuffer::Command::Scissor;
    cmd.args.scissor.x = scissor.r.x();
    cmd.args.scissor.y = scissor.r.y();
    cmd.args.scissor.w = scissor.r.z();
    cmd.args.scissor.h = scissor.r.w();
    QRHI_RES(QGles2CommandBuffer, cb)->commands.append(cmd);
}

void QRhiGles2::setBlendConstants(QRhiCommandBuffer *cb, const QVector4D &c)
{
    Q_ASSERT(inPass);
    QGles2CommandBuffer::Command cmd;
    cmd.cmd = QGles2CommandBuffer::Command::BlendConstants;
    cmd.args.blendConstants.r = c.x();
    cmd.args.blendConstants.g = c.y();
    cmd.args.blendConstants.b = c.z();
    cmd.args.blendConstants.a = c.w();
    QRHI_RES(QGles2CommandBuffer, cb)->commands.append(cmd);
}

void QRhiGles2::setStencilRef(QRhiCommandBuffer *cb, quint32 refValue)
{
    Q_ASSERT(inPass);
    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);

    QGles2CommandBuffer::Command cmd;
    cmd.cmd = QGles2CommandBuffer::Command::StencilRef;
    cmd.args.stencilRef.ref = refValue;
    cmd.args.stencilRef.ps = cbD->currentPipeline;
    cbD->commands.append(cmd);
}

void QRhiGles2::draw(QRhiCommandBuffer *cb, quint32 vertexCount,
                     quint32 instanceCount, quint32 firstVertex, quint32 firstInstance)
{
    Q_ASSERT(inPass);
    Q_UNUSED(instanceCount); // no instancing
    Q_UNUSED(firstInstance);
    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);

    QGles2CommandBuffer::Command cmd;
    cmd.cmd = QGles2CommandBuffer::Command::Draw;
    cmd.args.draw.ps = cbD->currentPipeline;
    cmd.args.draw.vertexCount = vertexCount;
    cmd.args.draw.firstVertex = firstVertex;
    cbD->commands.append(cmd);
}

void QRhiGles2::drawIndexed(QRhiCommandBuffer *cb, quint32 indexCount,
                            quint32 instanceCount, quint32 firstIndex, qint32 vertexOffset, quint32 firstInstance)
{
    Q_ASSERT(inPass);
    Q_UNUSED(instanceCount); // no instancing
    Q_UNUSED(firstInstance);
    Q_UNUSED(vertexOffset); // no glDrawElementsBaseVertex
    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);

    QGles2CommandBuffer::Command cmd;
    cmd.cmd = QGles2CommandBuffer::Command::DrawIndexed;
    cmd.args.drawIndexed.ps = cbD->currentPipeline;
    cmd.args.drawIndexed.indexCount = indexCount;
    cmd.args.drawIndexed.firstIndex = firstIndex;
    cbD->commands.append(cmd);
}

QRhi::FrameOpResult QRhiGles2::beginFrame(QRhiSwapChain *swapChain)
{
    Q_ASSERT(!inFrame);

    QGles2SwapChain *swapChainD = QRHI_RES(QGles2SwapChain, swapChain);
    ensureContext(swapChainD->surface);
    inFrame = true;

    executeDeferredReleases();
    QRHI_RES(QGles2CommandBuffer, &swapChainD->cb)->resetState();

    return QRhi::FrameOpSuccess;
}

QRhi::FrameOpResult QRhiGles2::endFrame(QRhiSwapChain *swapChain)
{
    Q_ASSERT(inFrame);

    QGles2SwapChain *swapChainD = QRHI_RES(QGles2SwapChain, swapChain);
    ensureContext(swapChainD->surface);
    executeCommandBuffer(&swapChainD->cb);

    inFrame = false;
    ++finishedFrameCount;

    if (swapChainD->surface) {
        ctx->swapBuffers(swapChainD->surface);
        buffersSwapped = true;
    }

    return QRhi::FrameOpSuccess;
}

void QRhiGles2::commitResourceUpdates(QRhiResourceUpdateBatch *resourceUpdates)
{
    QRhiResourceUpdateBatchPrivate *ud = QRhiResourceUpdateBatchPrivate::get(resourceUpdates);

    for (const QRhiResourceUpdateBatchPrivate::DynamicBufferUpdate &u : ud->dynamicBufferUpdates) {
        Q_ASSERT(u.buf->type == QRhiBuffer::Dynamic);
        QGles2Buffer *bufD = QRHI_RES(QGles2Buffer, u.buf);
        if (u.buf->usage.testFlag(QRhiBuffer::UniformBuffer)) {
            memcpy(bufD->ubuf.data() + u.offset, u.data.constData(), u.data.size());
            QGles2Buffer::ChangeRange &r(bufD->ubufChangeRange);
            if (r.changeBegin == -1 || u.offset < r.changeBegin)
                r.changeBegin = u.offset;
            if (r.changeEnd == -1 || u.offset + u.data.size() > r.changeEnd)
                r.changeEnd = u.offset + u.data.size();
        } else {
            f->glBindBuffer(bufD->target, bufD->buffer);
            f->glBufferSubData(bufD->target, u.offset, u.data.size(), u.data.constData());
        }
    }

    for (const QRhiResourceUpdateBatchPrivate::StaticBufferUpload &u : ud->staticBufferUploads) {
        Q_ASSERT(u.buf->type != QRhiBuffer::Dynamic);
        Q_ASSERT(u.data.size() == u.buf->size);
        QGles2Buffer *bufD = QRHI_RES(QGles2Buffer, u.buf);
        if (u.buf->usage.testFlag(QRhiBuffer::UniformBuffer)) {
            memcpy(bufD->ubuf.data(), u.data.constData(), u.data.size());
            bufD->ubufChangeRange = { 0, u.data.size() };
        } else {
            f->glBindBuffer(bufD->target, bufD->buffer);
            f->glBufferData(bufD->target, u.data.size(), u.data.constData(), GL_STATIC_DRAW);
        }
    }

    for (const QRhiResourceUpdateBatchPrivate::TextureUpload &u : ud->textureUploads) {
        QGles2Texture *texD = QRHI_RES(QGles2Texture, u.tex);
        const bool isCubeMap = texD->flags.testFlag(QRhiTexture::CubeMap);
        const GLenum targetBase = isCubeMap ? GL_TEXTURE_CUBE_MAP_POSITIVE_X : texD->target;
        for (int layer = 0, layerCount = u.desc.layers.count(); layer != layerCount; ++layer) {
            const QRhiResourceUpdateBatch::TextureUploadDescription::Layer &layerDesc(u.desc.layers[layer]);
            f->glBindTexture(targetBase + layer, texD->texture);
            for (int level = 0, levelCount = layerDesc.mipImages.count(); level != levelCount; ++level) {
                const QRhiResourceUpdateBatch::TextureUploadDescription::Layer::MipLevel mipDesc(layerDesc.mipImages[level]);
                f->glTexSubImage2D(targetBase + layer, level,
                                   0, 0, mipDesc.image.width(), mipDesc.image.height(),
                                   texD->glformat, texD->gltype, mipDesc.image.constBits());
            }
        }
    }

    ud->free();
}

static inline GLenum toGlTopology(QRhiGraphicsPipeline::Topology t)
{
    switch (t) {
    case QRhiGraphicsPipeline::Triangles:
        return GL_TRIANGLES;
    case QRhiGraphicsPipeline::TriangleStrip:
        return GL_TRIANGLE_STRIP;
    case QRhiGraphicsPipeline::Lines:
        return GL_LINES;
    case QRhiGraphicsPipeline::LineStrip:
        return GL_LINE_STRIP;
    case QRhiGraphicsPipeline::Points:
        return GL_POINTS;
    default:
        Q_UNREACHABLE();
        return GL_TRIANGLES;
    }
}

static inline GLenum toGlCullMode(QRhiGraphicsPipeline::CullMode c)
{
    switch (c) {
    case QRhiGraphicsPipeline::Front:
        return GL_FRONT;
    case QRhiGraphicsPipeline::Back:
        return GL_BACK;
    default:
        Q_UNREACHABLE();
        return GL_BACK;
    }
}

static inline GLenum toGlFrontFace(QRhiGraphicsPipeline::FrontFace f)
{
    switch (f) {
    case QRhiGraphicsPipeline::CCW:
        return GL_CCW;
    case QRhiGraphicsPipeline::CW:
        return GL_CW;
    default:
        Q_UNREACHABLE();
        return GL_CCW;
    }
}

static inline GLenum toGlBlendFactor(QRhiGraphicsPipeline::BlendFactor f)
{
    switch (f) {
    case QRhiGraphicsPipeline::Zero:
        return GL_ZERO;
    case QRhiGraphicsPipeline::One:
        return GL_ONE;
    case QRhiGraphicsPipeline::SrcColor:
        return GL_SRC_COLOR;
    case QRhiGraphicsPipeline::OneMinusSrcColor:
        return GL_ONE_MINUS_SRC_COLOR;
    case QRhiGraphicsPipeline::DstColor:
        return GL_DST_COLOR;
    case QRhiGraphicsPipeline::OneMinusDstColor:
        return GL_ONE_MINUS_DST_COLOR;
    case QRhiGraphicsPipeline::SrcAlpha:
        return GL_SRC_ALPHA;
    case QRhiGraphicsPipeline::OneMinusSrcAlpha:
        return GL_ONE_MINUS_SRC_ALPHA;
    case QRhiGraphicsPipeline::DstAlpha:
        return GL_DST_ALPHA;
    case QRhiGraphicsPipeline::OneMinusDstAlpha:
        return GL_ONE_MINUS_DST_ALPHA;
    case QRhiGraphicsPipeline::ConstantColor:
        return GL_CONSTANT_COLOR;
    case QRhiGraphicsPipeline::OneMinusConstantColor:
        return GL_ONE_MINUS_CONSTANT_COLOR;
    case QRhiGraphicsPipeline::ConstantAlpha:
        return GL_CONSTANT_ALPHA;
    case QRhiGraphicsPipeline::OneMinusConstantAlpha:
        return GL_ONE_MINUS_CONSTANT_ALPHA;
    case QRhiGraphicsPipeline::SrcAlphaSaturate:
        return GL_SRC_ALPHA_SATURATE;
    case QRhiGraphicsPipeline::Src1Color:
        Q_FALLTHROUGH();
    case QRhiGraphicsPipeline::OneMinusSrc1Color:
        Q_FALLTHROUGH();
    case QRhiGraphicsPipeline::Src1Alpha:
        Q_FALLTHROUGH();
    case QRhiGraphicsPipeline::OneMinusSrc1Alpha:
        qWarning("Unsupported blend factor %d", f);
        return GL_ZERO;
    default:
        Q_UNREACHABLE();
        return GL_ZERO;
    }
}

static inline GLenum toGlBlendOp(QRhiGraphicsPipeline::BlendOp op)
{
    switch (op) {
    case QRhiGraphicsPipeline::Add:
        return GL_FUNC_ADD;
    case QRhiGraphicsPipeline::Subtract:
        return GL_FUNC_SUBTRACT;
    case QRhiGraphicsPipeline::ReverseSubtract:
        return GL_FUNC_REVERSE_SUBTRACT;
    case QRhiGraphicsPipeline::Min:
        return GL_MIN;
    case QRhiGraphicsPipeline::Max:
        return GL_MAX;
    default:
        Q_UNREACHABLE();
        return GL_FUNC_ADD;
    }
}

static inline GLenum toGlCompareOp(QRhiGraphicsPipeline::CompareOp op)
{
    switch (op) {
    case QRhiGraphicsPipeline::Never:
        return GL_NEVER;
    case QRhiGraphicsPipeline::Less:
        return GL_LESS;
    case QRhiGraphicsPipeline::Equal:
        return GL_EQUAL;
    case QRhiGraphicsPipeline::LessOrEqual:
        return GL_LEQUAL;
    case QRhiGraphicsPipeline::Greater:
        return GL_GREATER;
    case QRhiGraphicsPipeline::NotEqual:
        return GL_NOTEQUAL;
    case QRhiGraphicsPipeline::GreaterOrEqual:
        return GL_GEQUAL;
    case QRhiGraphicsPipeline::Always:
        return GL_ALWAYS;
    default:
        Q_UNREACHABLE();
        return GL_ALWAYS;
    }
}

static inline GLenum toGlStencilOp(QRhiGraphicsPipeline::StencilOp op)
{
    switch (op) {
    case QRhiGraphicsPipeline::StencilZero:
        return GL_ZERO;
    case QRhiGraphicsPipeline::Keep:
        return GL_KEEP;
    case QRhiGraphicsPipeline::Replace:
        return GL_REPLACE;
    case QRhiGraphicsPipeline::IncrementAndClamp:
        return GL_INCR;
    case QRhiGraphicsPipeline::DecrementAndClamp:
        return GL_DECR;
    case QRhiGraphicsPipeline::Invert:
        return GL_INVERT;
    case QRhiGraphicsPipeline::IncrementAndWrap:
        return GL_INCR_WRAP;
    case QRhiGraphicsPipeline::DecrementAndWrap:
        return GL_DECR_WRAP;
    default:
        Q_UNREACHABLE();
        return GL_KEEP;
    }
}

static inline GLenum toGlMinFilter(QRhiSampler::Filter f, QRhiSampler::Filter m)
{
    switch (f) {
    case QRhiSampler::Nearest:
        if (m == QRhiSampler::None)
            return GL_NEAREST;
        else
            return m == QRhiSampler::Nearest ? GL_NEAREST_MIPMAP_NEAREST : GL_NEAREST_MIPMAP_LINEAR;
    case QRhiSampler::Linear:
        if (m == QRhiSampler::None)
            return GL_LINEAR;
        else
            return m == QRhiSampler::Nearest ? GL_LINEAR_MIPMAP_NEAREST : GL_LINEAR_MIPMAP_LINEAR;
    default:
        Q_UNREACHABLE();
        return GL_LINEAR;
    }
}

static inline GLenum toGlMagFilter(QRhiSampler::Filter f)
{
    switch (f) {
    case QRhiSampler::Nearest:
        return GL_NEAREST;
    case QRhiSampler::Linear:
        return GL_LINEAR;
    default:
        Q_UNREACHABLE();
        return GL_LINEAR;
    }
}

static inline GLenum toGlWrapMode(QRhiSampler::AddressMode m)
{
    switch (m) {
    case QRhiSampler::Repeat:
        return GL_REPEAT;
    case QRhiSampler::ClampToEdge:
        return GL_CLAMP_TO_EDGE;
    case QRhiSampler::Mirror:
        return GL_MIRRORED_REPEAT;
    case QRhiSampler::MirrorOnce:
        Q_FALLTHROUGH();
    case QRhiSampler::Border:
        qWarning("Unsupported wrap mode %d", m);
        return GL_CLAMP_TO_EDGE;
    default:
        Q_UNREACHABLE();
        return GL_CLAMP_TO_EDGE;
    }
}

void QRhiGles2::executeCommandBuffer(QRhiCommandBuffer *cb)
{
    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);
    GLenum indexType = GL_UNSIGNED_SHORT;
    quint32 indexStride = sizeof(quint16);
    quint32 indexOffset = 0;

    for (const QGles2CommandBuffer::Command &cmd : qAsConst(cbD->commands)) {
        switch (cmd.cmd) {
        case QGles2CommandBuffer::Command::Viewport:
            f->glViewport(cmd.args.viewport.x, cmd.args.viewport.y, cmd.args.viewport.w, cmd.args.viewport.h);
            f->glDepthRangef(cmd.args.viewport.d0, cmd.args.viewport.d1);
            break;
        case QGles2CommandBuffer::Command::Scissor:
            f->glScissor(cmd.args.scissor.x, cmd.args.scissor.y, cmd.args.scissor.w, cmd.args.scissor.h);
            break;
        case QGles2CommandBuffer::Command::BlendConstants:
            f->glBlendColor(cmd.args.blendConstants.r, cmd.args.blendConstants.g, cmd.args.blendConstants.b, cmd.args.blendConstants.a);
            break;
        case QGles2CommandBuffer::Command::StencilRef:
        {
            QGles2GraphicsPipeline *ps = QRHI_RES(QGles2GraphicsPipeline, cmd.args.stencilRef.ps);
            if (ps) {
                f->glStencilFuncSeparate(GL_FRONT, toGlCompareOp(ps->stencilFront.compareOp), cmd.args.stencilRef.ref, ps->stencilReadMask);
                f->glStencilFuncSeparate(GL_BACK, toGlCompareOp(ps->stencilBack.compareOp), cmd.args.stencilRef.ref, ps->stencilReadMask);
            } else {
                qWarning("No graphics pipeline active for setStencilRef; ignored");
            }
        }
            break;
        case QGles2CommandBuffer::Command::BindVertexBuffer:
        {
            QGles2GraphicsPipeline *ps = QRHI_RES(QGles2GraphicsPipeline, cmd.args.bindVertexBuffer.ps);
            if (ps) {
                for (const QRhiVertexInputLayout::Attribute &a : ps->vertexInputLayout.attributes) {
                    if (a.binding != cmd.args.bindVertexBuffer.binding)
                        continue;

                    // we do not support more than one vertex buffer
                    f->glBindBuffer(GL_ARRAY_BUFFER, cmd.args.bindVertexBuffer.buffer);

                    const int stride = ps->vertexInputLayout.bindings[a.binding].stride;
                    int size = 1;
                    GLenum type = GL_FLOAT;
                    switch (a.format) {
                    case QRhiVertexInputLayout::Attribute::Float4:
                        type = GL_FLOAT;
                        size = 4;
                        break;
                    case QRhiVertexInputLayout::Attribute::Float3:
                        type = GL_FLOAT;
                        size = 3;
                        break;
                    case QRhiVertexInputLayout::Attribute::Float2:
                        type = GL_FLOAT;
                        size = 2;
                        break;
                    case QRhiVertexInputLayout::Attribute::Float:
                        type = GL_FLOAT;
                        size = 1;
                        break;
                    case QRhiVertexInputLayout::Attribute::UNormByte4:
                        type = GL_UNSIGNED_BYTE;
                        size = 4;
                        break;
                    case QRhiVertexInputLayout::Attribute::UNormByte2:
                        type = GL_UNSIGNED_BYTE;
                        size = 2;
                        break;
                    case QRhiVertexInputLayout::Attribute::UNormByte:
                        type = GL_UNSIGNED_BYTE;
                        size = 1;
                        break;
                    default:
                        break;
                    }
                    quint32 ofs = a.offset + cmd.args.bindVertexBuffer.offset;
                    f->glVertexAttribPointer(a.location, size, type, GL_FALSE, stride,
                                             reinterpret_cast<const GLvoid *>(quintptr(ofs)));
                    f->glEnableVertexAttribArray(a.location);
                }
            } else {
                qWarning("No graphics pipeline active for setVertexInput; ignored");
            }
        }
            break;
        case QGles2CommandBuffer::Command::BindIndexBuffer:
            indexType = cmd.args.bindIndexBuffer.type;
            indexStride = indexType == GL_UNSIGNED_SHORT ? sizeof(quint16) : sizeof(quint32);
            indexOffset = cmd.args.bindIndexBuffer.offset;
            f->glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, cmd.args.bindIndexBuffer.buffer);
            break;
        case QGles2CommandBuffer::Command::Draw:
        {
            QGles2GraphicsPipeline *ps = QRHI_RES(QGles2GraphicsPipeline, cmd.args.draw.ps);
            if (ps)
                f->glDrawArrays(ps->drawMode, cmd.args.draw.firstVertex, cmd.args.draw.vertexCount);
            else
                qWarning("No graphics pipeline active for draw; ignored");
        }
            break;
        case QGles2CommandBuffer::Command::DrawIndexed:
        {
            QGles2GraphicsPipeline *ps = QRHI_RES(QGles2GraphicsPipeline, cmd.args.drawIndexed.ps);
            if (ps) {
                quint32 ofs = cmd.args.drawIndexed.firstIndex * indexStride + indexOffset;
                f->glDrawElements(ps->drawMode,
                                  cmd.args.drawIndexed.indexCount,
                                  indexType,
                                  reinterpret_cast<const GLvoid *>(quintptr(ofs)));
            } else {
                qWarning("No graphics pipeline active for drawIndexed; ignored");
            }
        }
            break;
        case QGles2CommandBuffer::Command::BindGraphicsPipeline:
            if (cmd.args.bindGraphicsPipeline.resOnlyChange) {
                setChangedUniforms(QRHI_RES(QGles2GraphicsPipeline, cmd.args.bindGraphicsPipeline.ps),
                                   cmd.args.bindGraphicsPipeline.srb,
                                   false);
            } else {
                executeBindGraphicsPipeline(cmd.args.bindGraphicsPipeline.ps, cmd.args.bindGraphicsPipeline.srb);
            }
            break;
        case QGles2CommandBuffer::Command::BindFramebuffer:
            if (cmd.args.bindFramebuffer.rt)
                f->glBindFramebuffer(GL_FRAMEBUFFER,
                                     QRHI_RES(QGles2TextureRenderTarget, cmd.args.bindFramebuffer.rt)->framebuffer);
            else
                f->glBindFramebuffer(GL_FRAMEBUFFER, ctx->defaultFramebufferObject());
            break;
        case QGles2CommandBuffer::Command::Clear:
            f->glDisable(GL_SCISSOR_TEST);
            if (cmd.args.clear.mask & GL_COLOR_BUFFER_BIT) {
                f->glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
                f->glClearColor(cmd.args.clear.c[0], cmd.args.clear.c[1], cmd.args.clear.c[2], cmd.args.clear.c[3]);
            }
            if (cmd.args.clear.mask & GL_DEPTH_BUFFER_BIT) {
                f->glDepthMask(GL_TRUE);
                f->glClearDepthf(cmd.args.clear.d);
            }
            if (cmd.args.clear.mask & GL_STENCIL_BUFFER_BIT) {
                f->glStencilMask(GL_TRUE);
                f->glClearStencil(cmd.args.clear.s);
            }
            f->glClear(cmd.args.clear.mask);
            break;
        default:
            break;
        }
    }
}

void QRhiGles2::executeBindGraphicsPipeline(QRhiGraphicsPipeline *ps, QRhiShaderResourceBindings *srb)
{
    QGles2GraphicsPipeline *psD = QRHI_RES(QGles2GraphicsPipeline, ps);

    // ### this needs some proper caching later on to minimize state changes

    if (ps->flags.testFlag(QRhiGraphicsPipeline::UsesScissor))
        f->glEnable(GL_SCISSOR_TEST);
    else
        f->glDisable(GL_SCISSOR_TEST);
    if (ps->cullMode == QRhiGraphicsPipeline::None) {
        f->glDisable(GL_CULL_FACE);
    } else {
        f->glEnable(GL_CULL_FACE);
        f->glCullFace(toGlCullMode(ps->cullMode));
    }
    f->glFrontFace(toGlFrontFace(ps->frontFace));
    if (!ps->targetBlends.isEmpty()) {
        const QRhiGraphicsPipeline::TargetBlend &blend(ps->targetBlends.first()); // no MRT
        GLboolean wr = blend.colorWrite.testFlag(QRhiGraphicsPipeline::R);
        GLboolean wg = blend.colorWrite.testFlag(QRhiGraphicsPipeline::G);
        GLboolean wb = blend.colorWrite.testFlag(QRhiGraphicsPipeline::B);
        GLboolean wa = blend.colorWrite.testFlag(QRhiGraphicsPipeline::A);
        f->glColorMask(wr, wg, wb, wa);
        if (blend.enable) {
            f->glEnable(GL_BLEND);
            f->glBlendFuncSeparate(toGlBlendFactor(blend.srcColor),
                                   toGlBlendFactor(blend.dstColor),
                                   toGlBlendFactor(blend.srcAlpha),
                                   toGlBlendFactor(blend.dstAlpha));
            f->glBlendEquationSeparate(toGlBlendOp(blend.opColor), toGlBlendOp(blend.opAlpha));
        } else {
            f->glDisable(GL_BLEND);
        }
    } else {
        f->glDisable(GL_BLEND);
    }
    if (ps->depthTest)
        f->glEnable(GL_DEPTH_TEST);
    else
        f->glDisable(GL_DEPTH_TEST);
    if (ps->depthWrite)
        f->glDepthMask(GL_TRUE);
    else
        f->glDepthMask(GL_FALSE);
    f->glDepthFunc(toGlCompareOp(ps->depthOp));
    if (ps->stencilTest) {
        f->glEnable(GL_STENCIL_TEST);
        f->glStencilFuncSeparate(GL_FRONT, toGlCompareOp(ps->stencilFront.compareOp), 0, ps->stencilReadMask);
        f->glStencilOpSeparate(GL_FRONT,
                               toGlStencilOp(ps->stencilFront.failOp),
                               toGlStencilOp(ps->stencilFront.depthFailOp),
                               toGlStencilOp(ps->stencilFront.passOp));
        f->glStencilMaskSeparate(GL_FRONT, ps->stencilWriteMask);
        f->glStencilFuncSeparate(GL_BACK, toGlCompareOp(ps->stencilBack.compareOp), 0, ps->stencilReadMask);
        f->glStencilOpSeparate(GL_BACK,
                               toGlStencilOp(ps->stencilBack.failOp),
                               toGlStencilOp(ps->stencilBack.depthFailOp),
                               toGlStencilOp(ps->stencilBack.passOp));
        f->glStencilMaskSeparate(GL_BACK, ps->stencilWriteMask);
    } else {
        f->glDisable(GL_STENCIL_TEST);
    }

    f->glUseProgram(psD->program);
    // buffer data cannot change within the pass so this time is as good to update uniforms as any
    setChangedUniforms(psD, srb, false);
}

void QRhiGles2::setChangedUniforms(QGles2GraphicsPipeline *psD, QRhiShaderResourceBindings *srb, bool changedOnly)
{
    for (int i = 0, ie = srb->bindings.count(); i != ie; ++i) {
        const QRhiShaderResourceBindings::Binding &b(srb->bindings[i]);
        switch (b.type) {
        case QRhiShaderResourceBindings::Binding::UniformBuffer:
        {
            QGles2Buffer *bufD = QRHI_RES(QGles2Buffer, b.ubuf.buf);
            if (changedOnly && bufD->ubufChangeRange.isNull()) // do not set again when nothing changed
                break;
            const QByteArray bufView = QByteArray::fromRawData(bufD->ubuf.constData() + b.ubuf.offset,
                                                               b.ubuf.maybeSize ? b.ubuf.maybeSize : bufD->size);
            for (QGles2GraphicsPipeline::Uniform &uniform : psD->uniforms) {
                if (uniform.binding == b.binding
                        && (!changedOnly ||
                            (uniform.offset >= uint(bufD->ubufChangeRange.changeBegin)
                             && uniform.offset < uint(bufD->ubufChangeRange.changeEnd))))
                {
                    memcpy(uniform.data.data(), bufView.constData() + uniform.offset, uniform.data.size());

                    switch (uniform.type) {
                    case QShaderDescription::Float:
                        f->glUniform1f(uniform.glslLocation, *reinterpret_cast<const float *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Vec2:
                        f->glUniform2fv(uniform.glslLocation, 1, reinterpret_cast<const float *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Vec3:
                        f->glUniform3fv(uniform.glslLocation, 1, reinterpret_cast<const float *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Vec4:
                        f->glUniform4fv(uniform.glslLocation, 1, reinterpret_cast<const float *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Mat2:
                        f->glUniformMatrix2fv(uniform.glslLocation, 1, GL_FALSE, reinterpret_cast<const float *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Mat3:
                        f->glUniformMatrix3fv(uniform.glslLocation, 1, GL_FALSE, reinterpret_cast<const float *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Mat4:
                        f->glUniformMatrix4fv(uniform.glslLocation, 1, GL_FALSE, reinterpret_cast<const float *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Int:
                        f->glUniform1i(uniform.glslLocation, *reinterpret_cast<const qint32 *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Int2:
                        f->glUniform2iv(uniform.glslLocation, 1, reinterpret_cast<const qint32 *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Int3:
                        f->glUniform3iv(uniform.glslLocation, 1, reinterpret_cast<const qint32 *>(uniform.data.constData()));
                        break;
                    case QShaderDescription::Int4:
                        f->glUniform4iv(uniform.glslLocation, 1, reinterpret_cast<const qint32 *>(uniform.data.constData()));
                        break;
                    // ### more types
                    default:
                        break;
                    }
                }
            }

            bufD->ubufChangeRange = QGles2Buffer::ChangeRange();
        }
            break;
        case QRhiShaderResourceBindings::Binding::SampledTexture:
        {
            QGles2Texture *texD = QRHI_RES(QGles2Texture, b.stex.tex);
            QGles2Sampler *samplerD = QRHI_RES(QGles2Sampler, b.stex.sampler);

            int texUnit = 0;
            for (QGles2GraphicsPipeline::Sampler &sampler : psD->samplers) {
                if (sampler.binding == b.binding) {
                    // ### should this use sampler->generation or something to prevent doing it over and over again
                    f->glActiveTexture(GL_TEXTURE0 + texUnit);
                    f->glBindTexture(texD->target, texD->texture);

                    f->glTexParameteri(texD->target, GL_TEXTURE_MIN_FILTER, samplerD->glminfilter);
                    f->glTexParameteri(texD->target, GL_TEXTURE_MAG_FILTER, samplerD->glmagfilter);
                    f->glTexParameteri(texD->target, GL_TEXTURE_WRAP_S, samplerD->glwraps);
                    f->glTexParameteri(texD->target, GL_TEXTURE_WRAP_T, samplerD->glwrapt);
                    f->glTexParameteri(texD->target, GL_TEXTURE_WRAP_R, samplerD->glwrapr);

                    f->glUniform1i(sampler.glslLocation, texUnit);
                    ++texUnit;
                }
            }
            if (texUnit)
                f->glActiveTexture(GL_TEXTURE0);
        }
            break;
        default:
            Q_UNREACHABLE();
            break;
        }
    }
}

void QRhiGles2::beginPass(QRhiRenderTarget *rt,
                          QRhiCommandBuffer *cb,
                          const QRhiColorClearValue &colorClearValue,
                          const QRhiDepthStencilClearValue &depthStencilClearValue,
                          QRhiResourceUpdateBatch *resourceUpdates)
{
    Q_ASSERT(!inPass);

    if (resourceUpdates)
        commitResourceUpdates(resourceUpdates);

    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);
    bool needsColorClear = true;
    QGles2BasicRenderTargetData *rtD = nullptr;
    QGles2CommandBuffer::Command fbCmd;
    fbCmd.cmd = QGles2CommandBuffer::Command::BindFramebuffer;
    switch (rt->type()) {
    case QRhiRenderTarget::RtRef:
        rtD = &QRHI_RES(QGles2ReferenceRenderTarget, rt)->d;
        fbCmd.args.bindFramebuffer.rt = nullptr;
        break;
    case QRhiRenderTarget::RtTexture:
    {
        QGles2TextureRenderTarget *rtTex = QRHI_RES(QGles2TextureRenderTarget, rt);
        rtD = &rtTex->d;
        needsColorClear = !rtTex->flags.testFlag(QRhiTextureRenderTarget::PreserveColorContents);
        fbCmd.args.bindFramebuffer.rt = rtTex;
    }
        break;
    default:
        Q_UNREACHABLE();
        break;
    }
    cbD->commands.append(fbCmd);

    cbD->currentTarget = rt;

    Q_ASSERT(rtD->attCount == 1 || rtD->attCount == 2);
    QGles2CommandBuffer::Command clearCmd;
    clearCmd.cmd = QGles2CommandBuffer::Command::Clear;
    clearCmd.args.clear.mask = 0;
    if (rtD->attCount > 1)
        clearCmd.args.clear.mask |= GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT;
    if (needsColorClear)
        clearCmd.args.clear.mask |= GL_COLOR_BUFFER_BIT;

    memcpy(clearCmd.args.clear.c, &colorClearValue.rgba, sizeof(float) * 4);
    clearCmd.args.clear.d = depthStencilClearValue.d;
    clearCmd.args.clear.s = depthStencilClearValue.s;

    cbD->commands.append(clearCmd);

    inPass = true;
}

void QRhiGles2::endPass(QRhiCommandBuffer *cb)
{
    Q_ASSERT(inPass);
    inPass = false;

    QGles2CommandBuffer *cbD = QRHI_RES(QGles2CommandBuffer, cb);
    cbD->currentTarget = nullptr;
}

QGles2Buffer::QGles2Buffer(QRhiImplementation *rhi, Type type, UsageFlags usage, int size)
    : QRhiBuffer(rhi, type, usage, size)
{
}

void QGles2Buffer::release()
{
    if (!buffer)
        return;

    QRhiGles2::DeferredReleaseEntry e;
    e.type = QRhiGles2::DeferredReleaseEntry::Buffer;

    e.buffer.buffer = buffer;

    buffer = 0;

    QRHI_RES_RHI(QRhiGles2);
    rhiD->releaseQueue.append(e);
}

bool QGles2Buffer::build()
{
    QRHI_RES_RHI(QRhiGles2);

    if (buffer)
        release();

    if (usage.testFlag(QRhiBuffer::UniformBuffer)) {
        // special since we do not support uniform blocks in this backend
        ubuf.resize(size);
        return true;
    }

    rhiD->ensureContext();

    if (usage.testFlag(QRhiBuffer::VertexBuffer))
        target = GL_ARRAY_BUFFER;
    if (usage.testFlag(QRhiBuffer::IndexBuffer))
        target = GL_ELEMENT_ARRAY_BUFFER;

    rhiD->f->glGenBuffers(1, &buffer);
    rhiD->f->glBindBuffer(target, buffer);
    rhiD->f->glBufferData(target, size, nullptr, type == Dynamic ? GL_DYNAMIC_DRAW : GL_STATIC_DRAW);

    return true;
}

QGles2RenderBuffer::QGles2RenderBuffer(QRhiImplementation *rhi, Type type, const QSize &pixelSize,
                                       int sampleCount, QRhiRenderBuffer::Hints hints)
    : QRhiRenderBuffer(rhi, type, pixelSize, sampleCount, hints)
{
}

void QGles2RenderBuffer::release()
{
    if (!renderbuffer)
        return;

    QRhiGles2::DeferredReleaseEntry e;
    e.type = QRhiGles2::DeferredReleaseEntry::RenderBuffer;

    e.renderbuffer.renderbuffer = renderbuffer;

    renderbuffer = 0;

    QRHI_RES_RHI(QRhiGles2);
    rhiD->releaseQueue.append(e);
}

bool QGles2RenderBuffer::build()
{
    QRHI_RES_RHI(QRhiGles2);

    if (renderbuffer)
        release();

    if (hints.testFlag(ToBeUsedWithSwapChainOnly))
        return true;

    rhiD->ensureContext();

    rhiD->f->glGenRenderbuffers(1, &renderbuffer);
    rhiD->f->glBindRenderbuffer(GL_RENDERBUFFER, renderbuffer);

    switch (type) {
    case QRhiRenderBuffer::DepthStencil:
        rhiD->f->glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, pixelSize.width(), pixelSize.height());
        break;
    default:
        Q_UNREACHABLE();
        break;
    }

    return true;
}

QGles2Texture::QGles2Texture(QRhiImplementation *rhi, Format format, const QSize &pixelSize, Flags flags)
    : QRhiTexture(rhi, format, pixelSize, flags)
{
}

static inline QSize safeSize(const QSize &size)
{
    return size.isEmpty() ? QSize(16, 16) : size;
}

void QGles2Texture::release()
{
    if (!texture)
        return;

    QRhiGles2::DeferredReleaseEntry e;
    e.type = QRhiGles2::DeferredReleaseEntry::Texture;

    e.texture.texture = texture;

    texture = 0;

    QRHI_RES_RHI(QRhiGles2);
    rhiD->releaseQueue.append(e);
}

bool QGles2Texture::build()
{
    QRHI_RES_RHI(QRhiGles2);

    if (texture)
        release();

    rhiD->ensureContext();

    const QSize size = safeSize(pixelSize);
    // ### adjust size for npot when repeat with npot is not supported?

    const bool isCube = flags.testFlag(CubeMap);
    const bool hasMipMaps = flags.testFlag(MipMapped);
    const int mipLevelCount = hasMipMaps ? qCeil(log2(qMax(size.width(), size.height()))) + 1 : 1;

    // ### more formats
    target = isCube ? GL_TEXTURE_CUBE_MAP : GL_TEXTURE_2D;
    glintformat = GL_RGBA;
    glformat = GL_RGBA;
    gltype = GL_UNSIGNED_BYTE;

    rhiD->f->glGenTextures(1, &texture);
    if (hasMipMaps || isCube) {
        const GLenum targetBase = isCube ? GL_TEXTURE_CUBE_MAP_POSITIVE_X : target;
        for (int layer = 0, layerCount = isCube ? 6 : 1; layer != layerCount; ++layer) {
            rhiD->f->glBindTexture(targetBase + layer, texture);
            for (int level = 0; level != mipLevelCount; ++level) {
                rhiD->f->glTexImage2D(targetBase + layer, level, glintformat,
                                      qFloor(double(qMax(1, size.width() >> level))), qFloor(double(qMax(1, size.height() >> level))),
                                      0, glformat, gltype, nullptr);
            }
        }
    } else {
        rhiD->f->glBindTexture(target, texture);
        rhiD->f->glTexImage2D(target, 0, glintformat, size.width(), size.height(), 0, glformat, gltype, nullptr);
    }

    return true;
}

QGles2Sampler::QGles2Sampler(QRhiImplementation *rhi, Filter magFilter, Filter minFilter, Filter mipmapMode,
                             AddressMode u, AddressMode v, AddressMode w)
    : QRhiSampler(rhi, magFilter, minFilter, mipmapMode, u, v, w)
{
}

void QGles2Sampler::release()
{
    // nothing to do here
}

bool QGles2Sampler::build()
{
    glminfilter = toGlMinFilter(minFilter, mipmapMode);
    glmagfilter = toGlMagFilter(magFilter);
    glwraps = toGlWrapMode(addressU);
    glwrapt = toGlWrapMode(addressV);
    glwrapr = toGlWrapMode(addressW);

    return true;
}

QGles2RenderPass::QGles2RenderPass(QRhiImplementation *rhi)
    : QRhiRenderPass(rhi)
{
}

void QGles2RenderPass::release()
{
    // nothing to do here
}

QGles2ReferenceRenderTarget::QGles2ReferenceRenderTarget(QRhiImplementation *rhi)
    : QRhiReferenceRenderTarget(rhi),
      d(rhi)
{
}

void QGles2ReferenceRenderTarget::release()
{
    // nothing to do here
}

QRhiRenderTarget::Type QGles2ReferenceRenderTarget::type() const
{
    return RtRef;
}

QSize QGles2ReferenceRenderTarget::sizeInPixels() const
{
    return d.pixelSize;
}

const QRhiRenderPass *QGles2ReferenceRenderTarget::renderPass() const
{
    return &d.rp;
}

QGles2TextureRenderTarget::QGles2TextureRenderTarget(QRhiImplementation *rhi, QRhiTexture *texture, Flags flags)
    : QRhiTextureRenderTarget(rhi, texture, flags),
      d(rhi)
{
}

QGles2TextureRenderTarget::QGles2TextureRenderTarget(QRhiImplementation *rhi, QRhiTexture *texture, QRhiRenderBuffer *depthStencilBuffer, Flags flags)
    : QRhiTextureRenderTarget(rhi, texture, depthStencilBuffer, flags),
      d(rhi)
{
}

QGles2TextureRenderTarget::QGles2TextureRenderTarget(QRhiImplementation *rhi, QRhiTexture *texture, QRhiTexture *depthTexture, Flags flags)
    : QRhiTextureRenderTarget(rhi, texture, depthTexture, flags),
      d(rhi)
{
}

void QGles2TextureRenderTarget::release()
{
    if (!framebuffer)
        return;

    QRhiGles2::DeferredReleaseEntry e;
    e.type = QRhiGles2::DeferredReleaseEntry::TextureRenderTarget;

    e.textureRenderTarget.framebuffer = framebuffer;

    framebuffer = 0;

    QRHI_RES_RHI(QRhiGles2);
    rhiD->releaseQueue.append(e);
}

bool QGles2TextureRenderTarget::build()
{
    QRHI_RES_RHI(QRhiGles2);

    if (framebuffer)
        release();

    Q_ASSERT(texture);
    Q_ASSERT(!depthStencilBuffer || !depthTexture);

    if (depthTexture)
        qWarning("QGles2TextureRenderTarget: depth textures not supported");

    rhiD->ensureContext();

    rhiD->f->glGenFramebuffers(1, &framebuffer);
    rhiD->f->glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);

    QGles2Texture *texD = QRHI_RES(QGles2Texture, texture);
    Q_ASSERT(texD->texture);

    rhiD->f->glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, texD->target, texD->texture, 0);
    d.pixelSize = texture->pixelSize;
    d.attCount = 1;

    if (depthStencilBuffer) {
        QGles2RenderBuffer *rbD = QRHI_RES(QGles2RenderBuffer, depthStencilBuffer);
        rhiD->f->glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rbD->renderbuffer);
        rhiD->f->glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbD->renderbuffer);
        d.attCount += 1;
    }

    GLenum status = rhiD->f->glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if (status != GL_NO_ERROR && status != GL_FRAMEBUFFER_COMPLETE) {
        qWarning("Framebuffer incomplete: 0x%x", status);
        return false;
    }

    return true;
}

QRhiRenderTarget::Type QGles2TextureRenderTarget::type() const
{
    return RtTexture;
}

QSize QGles2TextureRenderTarget::sizeInPixels() const
{
    return d.pixelSize;
}

const QRhiRenderPass *QGles2TextureRenderTarget::renderPass() const
{
    return &d.rp;
}

QGles2ShaderResourceBindings::QGles2ShaderResourceBindings(QRhiImplementation *rhi)
    : QRhiShaderResourceBindings(rhi)
{
}

void QGles2ShaderResourceBindings::release()
{
    // nothing to do here
}

bool QGles2ShaderResourceBindings::build()
{
    generation += 1;
    return true;
}

QGles2GraphicsPipeline::QGles2GraphicsPipeline(QRhiImplementation *rhi)
    : QRhiGraphicsPipeline(rhi)
{
}

void QGles2GraphicsPipeline::release()
{
    if (!program)
        return;

    QRhiGles2::DeferredReleaseEntry e;
    e.type = QRhiGles2::DeferredReleaseEntry::Pipeline;

    e.pipeline.program = program;

    program = 0;
    uniforms.clear();
    samplers.clear();

    QRHI_RES_RHI(QRhiGles2);
    rhiD->releaseQueue.append(e);
}

bool QGles2GraphicsPipeline::build()
{
    QRHI_RES_RHI(QRhiGles2);

    if (program)
        release();

    rhiD->ensureContext();

    drawMode = toGlTopology(topology);

    program = rhiD->f->glCreateProgram();

    for (const QRhiGraphicsShaderStage &shaderStage : qAsConst(shaderStages)) {
        const bool isVertex = shaderStage.type == QRhiGraphicsShaderStage::Vertex;
        const bool isFragment = shaderStage.type == QRhiGraphicsShaderStage::Fragment;
        if (!isVertex && !isFragment)
            continue;

        GLuint shader = rhiD->f->glCreateShader(isVertex ? GL_VERTEX_SHADER : GL_FRAGMENT_SHADER);
        QBakedShader::ShaderSourceVersion ver;
        if (rhiD->ctx->isOpenGLES())
            ver = { 100, QBakedShader::ShaderSourceVersion::GlslEs };
        else
            ver = { 120 };
        const QByteArray source = shaderStage.shader.shader({ QBakedShader::GlslShader, ver }).shader;
        if (source.isEmpty()) {
            qWarning() << "No GLSL" << ver.version << "shader code found in baked shader" << shaderStage.shader;
            return false;
        }
        const char *srcStr = source.constData();
        const GLint srcLength = source.count();
        rhiD->f->glShaderSource(shader, 1, &srcStr, &srcLength);
        rhiD->f->glCompileShader(shader);
        GLint compiled = 0;
        rhiD->f->glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
        if (!compiled) {
            GLint infoLogLength = 0;
            rhiD->f->glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLogLength);
            QByteArray log;
            if (infoLogLength > 1) {
                GLsizei length = 0;
                log.resize(infoLogLength);
                rhiD->f->glGetShaderInfoLog(shader, infoLogLength, &length, log.data());
            }
            qWarning("Failed to compile shader: %s\nSource was:\n%s", log.constData(), source.constData());
            return false;
        }

        rhiD->f->glAttachShader(program, shader);
        rhiD->f->glDeleteShader(shader);

        if (isVertex)
            vsDesc = shaderStage.shader.description();
        else
            fsDesc = shaderStage.shader.description();
    }

    for (auto inVar : vsDesc.inputVariables()) {
        const QByteArray name = inVar.name.toUtf8();
        rhiD->f->glBindAttribLocation(program, inVar.location, name.constData());
    }

    rhiD->f->glLinkProgram(program);
    GLint linked = 0;
    rhiD->f->glGetProgramiv(program, GL_LINK_STATUS, &linked);
    if (!linked) {
        GLint infoLogLength = 0;
        rhiD->f->glGetProgramiv(program, GL_INFO_LOG_LENGTH, &infoLogLength);
        QByteArray log;
        if (infoLogLength > 1) {
            GLsizei length = 0;
            log.resize(infoLogLength);
            rhiD->f->glGetProgramInfoLog(program, infoLogLength, &length, log.data());
        }
        qWarning("Failed to link shader program: %s", log.constData());
        return false;
    }

    auto lookupUniforms = [this, rhiD](const QShaderDescription::UniformBlock &ub) {
        const QByteArray prefix = ub.structName.toUtf8() + '.';
        for (const QShaderDescription::BlockVariable &blockMember : ub.members) {
            // ### no array support for now
            Uniform uniform;
            uniform.type = blockMember.type;
            const QByteArray name = prefix + blockMember.name.toUtf8();
            uniform.glslLocation = rhiD->f->glGetUniformLocation(program, name.constData());
            if (uniform.glslLocation >= 0) {
                uniform.binding = ub.binding;
                uniform.offset = blockMember.offset;
                uniform.data.resize(blockMember.size);
                uniforms.append(uniform);
            }
        }
    };

    for (const QShaderDescription::UniformBlock &ub : vsDesc.uniformBlocks())
        lookupUniforms(ub);

    for (const QShaderDescription::UniformBlock &ub : fsDesc.uniformBlocks())
        lookupUniforms(ub);

    auto lookupSamplers = [this, rhiD](const QShaderDescription::InOutVariable &v) {
        Sampler sampler;
        const QByteArray name = v.name.toUtf8();
        sampler.glslLocation = rhiD->f->glGetUniformLocation(program, name.constData());
        if (sampler.glslLocation >= 0) {
            sampler.binding = v.binding;
            samplers.append(sampler);
        }
    };

    for (const QShaderDescription::InOutVariable &v : vsDesc.combinedImageSamplers())
        lookupSamplers(v);

    for (const QShaderDescription::InOutVariable &v : fsDesc.combinedImageSamplers())
        lookupSamplers(v);

    generation += 1;
    return true;
}

QGles2CommandBuffer::QGles2CommandBuffer(QRhiImplementation *rhi)
    : QRhiCommandBuffer(rhi)
{
    resetState();
}

void QGles2CommandBuffer::release()
{
    Q_UNREACHABLE();
}

QGles2SwapChain::QGles2SwapChain(QRhiImplementation *rhi)
    : QRhiSwapChain(rhi),
      rt(rhi),
      cb(rhi)
{
}

void QGles2SwapChain::release()
{
    // nothing to do here
}

QRhiCommandBuffer *QGles2SwapChain::currentFrameCommandBuffer()
{
    return &cb;
}

QRhiRenderTarget *QGles2SwapChain::currentFrameRenderTarget()
{
    return &rt;
}

const QRhiRenderPass *QGles2SwapChain::defaultRenderPass() const
{
    return rt.renderPass();
}

QSize QGles2SwapChain::requestedSizeInPixels() const
{
    return pixelSize;
}

QSize QGles2SwapChain::effectiveSizeInPixels() const
{
    return pixelSize;
}

bool QGles2SwapChain::build(QWindow *window, const QSize &requestedPixelSize, SurfaceImportFlags flags,
                            QRhiRenderBuffer *depthStencil, int sampleCount)
{
    Q_UNUSED(flags);
    Q_UNUSED(sampleCount);

    surface = window;
    pixelSize = requestedPixelSize;

    rt.d.pixelSize = pixelSize;
    rt.d.attCount = depthStencil ? 2 : 1;

    return true;
}

bool QGles2SwapChain::build(QObject *target)
{
    // ### some day this could support QOpenGLWindow, OpenGLWidget, ...
    Q_UNUSED(target);
    return false;
}

QT_END_NAMESPACE
